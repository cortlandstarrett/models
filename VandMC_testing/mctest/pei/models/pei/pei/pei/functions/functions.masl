//! ACTIVITY BEGIN. '5b2dd722-eec1-43c7-a8d9-ca28f0be7d11' DO NOT EDIT THIS LINE.
private service pei::do_creates () is
a : instance of plug;
b : instance of socket;
c1 : instance of dog; c2 : instance of dog; c3 : instance of dog; c4 : instance of dog; c5 : instance of dog;
d1 : instance of dog_owner; d2 : instance of dog_owner; e0 : instance of host;
e1 : instance of host; e2 : instance of host;
f1 : instance of device; f2 : instance of device; f3 : instance of device;
g1 : instance of connection; g2 : instance of connection; g3 : instance of connection; g4 : instance of connection;
h1 : instance of transmission; h2 : instance of transmission; h3 : instance of transmission; h4 : instance of transmission; h : instance of transmission;
i1 : instance of car; i2 : instance of car; i3 : instance of car; i4 : instance of car;
j1 : instance of sedan;
k1 : instance of sports_car; k2 : instance of sports_car; k3 : instance of sports_car;
l1 : instance of convertible; l2 : instance of convertible; l3 : instance of convertible;
m1 : instance of report_line; m2 : instance of report_line; m3 : instance of report_line; m4 : instance of report_line; m5 : instance of report_line;
n1 : instance of employee; n2 : instance of employee; n3 : instance of employee; n4 : instance of employee; n5 : instance of employee; n6 : instance of employee;
o1 : instance of group_member; o2 : instance of group_member; o3 : instance of group_member; o4 : instance of group_member; o5 : instance of group_member;
p1 : instance of automobile; p2 : instance of automobile; p3 : instance of automobile;
q1 : instance of jurisdiction; q2 : instance of jurisdiction; q3 : instance of jurisdiction;
r1 : instance of license; r2 : instance of license; r3 : instance of license;
s1 : instance of AtoD_converter; s2 : instance of AtoD_converter;
t1 : instance of analog_input; t2 : instance of analog_input; t3 : instance of analog_input; t4 : instance of analog_input; t5 : instance of analog_input;
u1 : instance of sample; u2 : instance of sample; u3 : instance of sample; u4 : instance of sample; u5 : instance of sample;
v1 : instance of marriage; v2 : instance of marriage;
w1 : instance of person; w2 : instance of person; w3 : instance of person; w4 : instance of person;
x1 : instance of friend; x2 : instance of friend; x3 : instance of friend; x4 : instance of friend; x5 : instance of friend; x6 : instance of friend;
y1 : instance of friendship; y2 : instance of friendship; y3 : instance of friendship; y4 : instance of friendship; y5 : instance of friendship; y6 : instance of friendship; y7 : instance of friendship; y8 : instance of friendship; y9 : instance of friendship;
z1 : instance of dealer; z2 : instance of dealer; z3 : instance of dealer;
zz1 : instance of deal; zz2 : instance of deal; zz3 : instance of deal; zz4 : instance of deal; zz5 : instance of deal; zz6 : instance of deal; zz7 : instance of deal;

begin
// Set up instances for existence test later on.

// plug R1 socket
a := create plug( aID => 99 ); // extras to see in PEIs
a := create plug( aID => 98 );
b := create socket( bID => 2, i => 2 );
a := create plug( aID => 1, i => 1, bID => b.bID );
link a R1 b;
b := create socket( bID => 4, i => 4 );
a := create plug( aID => 3, i => 3, bID => b.bID );
link a R1 b;
b := create socket( bID => 6, i => 6 );
a := create plug( aID => 5, i => 5, bID => b.bID );
link a R1 b;
b := create socket( bID => 8 ); // extra to see it in PEIs

// dog R2 dog_owner
d1 := create dog_owner( dID => 1 ); // extra
d2 := create dog_owner( dID => 2, name => "DeeTwo" );
c1 := create dog( cID => 1, dID => d2.dID );
c2 := create dog( cID => 2, dID => d2.dID );
c3 := create dog( cID => 3, dID => d2.dID );
c4 := create dog( cID => 4, dID => d2.dID );
c5 := create dog( cID => 5 ); // extra
link c1 R2 d2;
link d2 R2 c2;
link d2 R2 c3;
link c4 R2 d2;

// host R3 device using connection
e0 := create host( eID => 100, ratio => 0.1 );
e1 := create host( eID => 1, ratio => 3.14 );
e2 := create host( eID => 2, ratio => 2.718 );
f3 := create device( fID => 3, enabled => true );
f2 := create device( fID => 2, enabled => false );
f1 := create device( fID => 1, enabled => true );
g1 := create connection( gID => 1, eID => e1.eID, fID => f1.fID );
g2 := create connection( gID => 2, eID => e1.eID, fID => f2.fID );
g3 := create connection( gID => 3, eID => e2.eID, fID => f3.fID );
g4 := create connection( gID => 4, eID => e1.eID, fID => f3.fID );
link e1 R3 f1 using g1;
link f2 R3 e1 using g2;
link f3 R3 e2 using g3;
link e1 R3 f3 using g4;

// transmission R4 (reflexive)
h1 := create transmission( hID => 1 );
h2 := create transmission( hID => 2, follows => h1.hID );
h := create transmission( hID => 99 ); // extra to see in PEIs
h3 := create transmission( hID => 3, follows => h2.hID );
h4 := create transmission( hID => 4, follows => h3.hID );
link h1 R2.precedes h2;
link h2 R2.precedes h3;
link h4 R2.follows h3;

// car R5 sedan, sports_car R6 convertible
i4 := create car( iID => 400, common => 400 );
i3 := create car( iID => 300, common => 300 );
i2 := create car( iID => 200, common => 200 );
i1 := create car( iID => 100, common => 100 );
j1 := create sedan( jID => 2, specialJ => 2, iID = i1.iID );
k1 := create sports_car( kID => 11, specialcommon => 11, iID = i4.iID );
k2 := create sports_car( kID => 22, specialcommon => 22, iID = i3.iID );
k3 := create sports_car( kID => 33, specialcommon => 33, iID = i2.iID );
l2 := create convertible( lID => 222, specialL => 222, kID = k3.iID );
l3 := create convertible( lID => 333, specialL => 333, kID = k2.iID );
l1 := create convertible( lID => 111, specialL => 111, kID = k1.iID );
link i1 R5 j1;
link i2 R5 k3;
link k2 R5 i3;
link i4 R5 k1;
link l1 R6 k1;
link l3 R6 k2;
link k3 R5 l2;

// group_member R8 reflexive
o2 := create group_member( oID => 2, voo => "Cort", teacheroID => o2.OID );
o1 := create group_member( oID => 1, voo => "Kenny" );
o3 := create group_member( oID => 3, voo => "Amy", teacheroID => o1.OID );
o4 := create group_member( oID => 4, voo => "Ellen", teacheroID => o1.OID );
o5 := create group_member( oID => 5, voo => "Brad", teacheroID => o1.OID );
link o1 R8.teaches o2; // Kenny teaches Cort.
link o2 R8.teaches o3; // Cort teaches Amy.
link o4 R8.learns_from o2; // Ellen learns from Cort.
link o5 R8.learns_from o2; // Brad learns from Cort.

// employee R7 reflexive using report_line
n1 := create employee( nID => 1, name => "Pete" );
n2 := create employee( nID => 2, name => "Dave" );
n3 := create employee( nID => 3, name => "Alex" );
n4 := create employee( nID => 4, name => "Jenn" );
n5 := create employee( nID => 5, name => "Cale" );
n6 := create employee( nID => 6, name => "Chris" );
m1 := create report_line( mID => 1, department => "SW", works_for_nID => n1.nID, manages_nID => n3.nID );
m2 := create report_line( mID => 2, department => "SW", works_for_nID => n1.nID, manages_nID => n4.nID );
m3 := create report_line( mID => 3, department => "HW", works_for_nID => n2.nID, manages_nID => n5.nID );
m4 := create report_line( mID => 4, department => "MEC", works_for_nID => n6.nID, manages_nID => n1.nID );
m5 := create report_line( mID => 5, department => "MEC", works_for_nID => n6.nID, manages_nID => n2.nID );
link n1 R7.manages n3 using m1;   // Pete manages Alex.
link n1 R7.manages n4 using m2;   // Pete manages Jenn.
link n5 R7.works_for n2 using m3; // Cale works for Dave.
link n1 R7.works_for n6 using m4; // Pete works for Chris.
link n6 R7.manages n2 using m5;   // Chris manages Dave.

// automobile R9 jurisdiction using license
p1 := create automobile( eyedee => "Rox" );
p2 := create automobile( eyedee => "Bita" );
p3 := create automobile( eyedee => "Tina" );
q1 := create jurisdiction( deeeye => "Shane" );
q2 := create jurisdiction( deeeye => "Rusty" );
q3 := create jurisdiction( deeeye => "Cort" );
r1 := create license( city => "Indianapolis", pID => p1.eyedee, qID => q3.deeeye );
r2 := create license( city => "Lockport", pID => p3.eyedee, qID => q1.deeeye );
r3 := create license( city => "Battleground", pID => p2.eyedee, qID => q2.deeeye );
link p1 R9 q3 using r1;
link q2 R9 p2 using r3;
link p3 R9 q1 using r2;

// AtoD_converter R10 analog_input using sample
s1 := create AtoD_converter( s => "Rox" );
s2 := create AtoD_converter( s => "Jacqui" );
t1 := create analog_input( t => "Clare" );
t2 := create analog_input( t => "Katrina" );
t3 := create analog_input( t => "Colleen" );
t4 := create analog_input( t => "Hannah" );
t5 := create analog_input( t => "Ruby" );
u5 := create sample( s => "Oct", sID => s2.sID, tID => t1.tID );
u4 := create sample( s => "Aug", sID => s2.sID, tID => t2.tID );
u3 := create sample( s => "Apr", sID => s2.sID, tID => t3.tID );
u2 := create sample( s => "Dec", sID => s1.sID, tID => t4.tID );
u1 := create sample( s => "Nov", sID => s1.sID, tID => t5.tID );
link s1 R10 t4 using u2;
link s1 R10 t5 using u1;
link t1 R10 s2 using u5;
link t2 R10 s2 using u4;
link s2 R10 t3 using u3;

// person R11 reflexive using marriage
w1 := create person( name => "Cort" );
w2 := create person( name => "Rox" );
w3 := create person( name => "Sean" );
w4 := create person( name => "Jacqui" );
v1 := create marriage( year => 1988, husband => w1.name, wife => w2.name );
v2 := create marriage( year => 1990, husband => w3.name, wife => w4.name );
link w1 R11.is_husband of w2 using v1;
link w4 R11.is_wife_of w3 using v2;

// friends and friendships
x1 := create friend( name => "Cort", age => 39 );
x2 := create friend( name => "Rox", age => 38 );
x3 := create friend( name => "Sevina", age => 35 );
x4 := create friend( name => "Joe", age => 43 );
x5 := create friend( name => "Scott", age => 42 );
x6 := create friend( name => "Jason", age => 31 );
y1 := create friendship( duration => 1, closeness => 10, buddy => x1.name, pal => x2.name );
y2 := create friendship( duration => 2, closeness => 20, buddy => x3.name, pal => x1.name );
y3 := create friendship( duration => 3, closeness => 30, buddy => x4.name, pal => x1.name );
y4 := create friendship( duration => 4, closeness => 40, buddy => x5.name, pal => x1.name );
y5 := create friendship( duration => 5, closeness => 50, buddy => x1.name, pal => x6.name );
y6 := create friendship( duration => 6, closeness => 60, buddy => x2.name, pal => x3.name );
y7 := create friendship( duration => 7, closeness => 70, buddy => x4.name, pal => x5.name );
y8 := create friendship( duration => 8, closeness => 80, buddy => x6.name, pal => x4.name );
y9 := create friendship( duration => 9, closeness => 90, buddy => x6.name, pal => x5.name );
// friends of Cort
link x1 R12.is_buddy_of x2 using y1;
link x1 R12.is_pal_of x3 using y2;
link x4 R12.is_buddy_of x1 using y3;
link x5 R12.is_pal_of x1 using y4;
link x1 R12.is_buddy_of x6 using y5;
// friends of Rox
link x3 R12.is_pal_of x2 using y6;
// friends of Joe
link x4 R12.is_buddy_of x5 using y7;
link x4 R12.is_pal_of x6 using y8;
// friends of Scott
link x6 R12.is_buddy_of x5 using y9;


// dealers and deals
z1 := create dealer( name => "Joe", worth => 1 );
z2 := create dealer( name => "Pat", worth => 2 );
z3 := create dealer( name => "Jason", worth => 3 );
zz1 := create deal( xaction => 1, value => -1, buyer => z2.name, seller => z1.name );
zz2 := create deal( xaction => 2, value => 2, buyer => z1.name, seller => z3.name );
zz3 := create deal( xaction => 3, value => -3, buyer => z3.name, seller => z2.name );
zz4 := create deal( xaction => 4, value => 4, buyer => z3.name, seller => z1.name );
zz5 := create deal( xaction => 5, value => -5, buyer => z1.name, seller => z2.name );
zz6 := create deal( xaction => 6, value => 6, buyer => z2.name, seller => z3.name );
zz7 := create deal( xaction => 7, value => -7, buyer => z2.name, seller => z1.name );
link z1 R13.sells_to z2 using zz1;
link z1 R13.buys_from z3 using zz2;
link z2 R13.sells_to z3 using zz3;
link z3 R13.buys_from z1 using zz4;
link z2 R13.sells_to z1 using zz5;
link z2 R13.buys_from z3 using zz6;
link z1 R13.sells_to z2 using zz7;

end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'ee0b21c6-3e1f-4b2b-9441-00b6e64ca6eb' DO NOT EDIT THIS LINE.
private service pei::setup () is
// 
// Check to see if any instances are already here.
// This would mean that we have restored from NVS
// or that preexisting instances were defined in data.
//

select any a from instances of plug;
if ( empty a )

  //
  // Set up instances for existance test later on.
  //

  ::do_creates();

end if;   // if empty a
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'b6ece4d0-3a14-4e5a-87e6-23378a779c47' DO NOT EDIT THIS LINE.
private service pei::test () is
//
// Test that an instance of A already exists.
//

select any a from instances of plug;
if (empty a)
  LOG::LogFailure( message:"test1.20:  Failed to select a." );
end if;

select many as from instances of plug;
if (cardinality as != 5)
  LOG::LogFailure( message:"test1.21:  Wrong number of As." );
end if;
select many as_again from instances of plug;
if ( as != as_again )
  LOG::LogFailure( message:"set of As and As_again do not match." );
end if;

create object instance a1 of plug; a1.i = 101;
select any a from instances of A where (selected.i == 1);
if (empty a)
  LOG::LogFailure( message:"test1.22:  Failed to select a where." );
end if;
delete object instance a1;

select any b from instances of B where (selected.i == 20);
if (not empty b)
  LOG::LogFailure( message:"test1.23:  Selected non-existant B." );
end if;

select any b from instances of B where (selected.i == 2);
if (empty b)
  LOG::LogFailure( message:"test1.24:  Failed to select b where." );
end if;

//
// Test that there is a B related to this A.
//
select any a from instances of A where (selected.i == 3);
select one b related by a->B[R1];
if (empty b)
  LOG::LogFailure( message:"test1.40:  Failed to select b across R1." );
end if;
if (b.i != 4)
  LOG::LogFailure( message:"test1.41:  Selected wrong b across R1." );
  if ( a.bID != b.bID )
    LOG::LogFailure( message:"test1.42:  A/B referential mismatch" );
  end if;
end if;
select one same_a related by a->B[R1]->A[R1];
if ( empty same_a )
  LOG::LogFailure( message:"test1.43:  Did not find a out and back across R1." );
else
  if ( a != same_a )
    LOG::LogFailure( message:"test1.43a:  a and same_a not the same." );
  end if;
end if;

//
// Test that there is an A related to this B.
//
select one a related by b->A[R1];
if (empty a)
  LOG::LogFailure( message:"test1.44:  Failed to select a across R1." );
end if;
if (a.i != 3)
  LOG::LogFailure( message:"test1.45:  Selected wrong a across R1." );
end if;
unrelate a from b across R1;
relate a to b across R1;

//
// Test for a D.
//
select any d from instances of D where ( selected.name == "DeeTwo" );
if (empty d)
  LOG::LogFailure( message:"test1.52:  Failed to select d from Ds.");
end if;

//
// Test for many Cs related to D.
//
select many cs related by d->C[R2];
if ( cardinality cs != 4 )
  LOG::LogFailure( message:"test1.62:  Failed to select Cs from D.");
end if;
for each c in cs
  select one d related by c->D[R2];
  if ( d.name != "DeeTwo" )
    LOG::LogFailure( message:"test1.63:  Failed to select D from C.");
  end if;
  if ( c.dID != d.dID )
    LOG::LogFailure( message:"test1.64:  C/D referential mismatch");
  end if;
end for;

//
// Test associatives.
//
select any e from instances of E where ( selected.eID == 2 );
if ( empty e )
  LOG::LogFailure( message:"test1.70:  Failed to select E.");
end if;
select any f related by e->F[R3];
if ( empty f )
  LOG::LogFailure( message:"test1.71:  Failed to select F.");
  if ( f.fID != 3 )
    LOG::LogFailure( message:"test1.72:  Selected wrong F across R3.");
  end if;
end if;
select many es related by f->E[R3];
if ( cardinality es != 2 )
  LOG::LogFailure( message:"test1.73:  Selected wrong count of Fs.");
end if;
select any g related by e->G[R3];
if ( g.gID != 3 )
  LOG::LogFailure( message:"test1.74:  Selected incorrect G.");
end if;
if ( ( g.eID != e.eID ) or ( g.fID != f.fID ) )
  LOG::LogFailure( message:"test1.75:  E/F/G referential mismatch.");
end if;
for each e in es
  if ( ( e.eID != 1 ) and ( e.eID != 2 ) )
    LOG::LogFailure( message:"test1.76:  Selected incorrect Es.");
  end if;
end for;

//
// Test reflexives.
//
select any h1 from instances of H where ( selected.hID == 1 );
if ( empty h1 )
  LOG::LogFailure( message:"test1.80:  Failed to select H.");
end if;
select one h2 related by h1->H[R4.'precedes'];
if ( h2.hID != 2 )
  LOG::LogFailure( message:"test1.81:  Selected incorrect H.");
end if;
if ( h1.hID != h2.follows )
  LOG::LogFailure( message:"test1.81a:  H referential mismatch");
end if;
select one h3 related by h2->H[R4.'precedes'];
if ( h3.hID != 3 )
  LOG::LogFailure( message:"test1.82:  Selected incorrect H.");
end if;
if ( h2.hID != h3.follows )
  LOG::LogFailure( message:"test1.82a:  H referential mismatch");
end if;
select one h related by h1->H[R4.'precedes']->H[R4.'precedes'];
if ( h.hID != 3 )
  LOG::LogFailure( message:"test1.83:  Selected incorrect H.");
end if;
select one h related by h3->H[R4.'follows']->H[R4.'follows'];
if ( h.hID != 1 )
  LOG::LogFailure( message:"test1.84:  Selected incorrect H.");
end if;
select any h from instances of H where ( selected.hID == 2 );
if ( empty h )
  LOG::LogFailure( message:"test1.85:  Failed to select H.");
end if;
select one hp related by h->H[R4.'follows'];
if ( hp.hID != 1 )
  LOG::LogFailure( message:"test1.86:  Selected incorrect H.");
end if;
if ( hp.hID != h.follows )
  LOG::LogFailure( message:"test1.86a:  H referential mismatch");
end if;
select one hf related by h->H[R4.'precedes'];
if ( hf.hID != 3 )
  LOG::LogFailure( message:"test1.87:  Selected incorrect H.");
end if;
select one h related by h3->H[R4.'precedes'];
if ( h.hID != 4 )
  LOG::LogFailure( message:"test1.88:  Selected incorrect H.");
end if;
if ( h3.hID != h.follows )
  LOG::LogFailure( message:"test1.88a:  H referential mismatch");
end if;

//
// Test sub/supers.
//
select any i from instances of I where ( selected.iID == 200 );
if ( empty i )
  LOG::LogFailure( message:"test1.90:  Failed to select I.");
end if;
select one k related by i->K[R5];
if ( empty k )
  LOG::LogFailure( message:"test1.91:  Failed to select K.");
else
  if ( k.kID != 33 )
    LOG::LogFailure( message:"test1.92:  Selected incorrect K.");
  end if;
  if ( i.iID != k.iID )
    LOG::LogFailure( message:"test1.92a:  I/K referential mismatch");
  end if;
end if;
select one l related by i->K[R5]->L[R6];
if ( empty l )
  LOG::LogFailure( message:"test1.93:  Failed to select L.");
else
  if ( l.lID != 222 )
    LOG::LogFailure( message:"test1.94:  Selected incorrect L.");
  end if;
  if ( l.kID != k.kID )
    LOG::LogFailure( message:"test1.94a:  L/K referential mismatch");
  end if;
end if;

//
// Test reflexive asymmetrics.
//
select any o from instances of O where ( selected.voo == "Cort" );
select many os related by o->O[R8.'teaches'];
if ( cardinality os != 3 )
  LOG::LogFailure( message:"test1.C2:  Failed to select Os.");
end if;
select one o1 related by o->O[R8.'learns_from'];
if ( o1.voo != "Kenny" )
  LOG::LogFailure( message:"test1.C3:  Selected incorrect O.");
else
  if ( o.teacheroID != o1.oID )
    LOG::LogFailure( message:"test1.C3a:  O referential mismatch");
  end if;
end if;
select any o from instances of O where ( selected.voo == "Ellen" );
select one o1 related by o->O[R8.'learns_from'];
if ( o1.voo != "Cort" )
  LOG::LogFailure( message:"test1.C4:  Selected incorrect O.");
else
  if ( o.teacheroID != o1.oID )
    LOG::LogFailure( message:"test1.C4a:  O referential mismatch");
  end if;
end if;
select any o from instances of O where ( selected.voo == "Amy" );
select one o1 related by o->O[R8.'learns_from'];
if ( o1.voo != "Cort" )
  LOG::LogFailure( message:"test1.C5:  Selected incorrect O.");
else
  if ( o.teacheroID != o1.oID )
    LOG::LogFailure( message:"test1.C5a:  O referential mismatch");
  end if;
end if;

//
// Test reflexive associatives.
//
select any n from instances of N where ( selected.name == "Chris" );
select many ns related by n->N[R7.'manages'];
if ( cardinality ns != 2 )
  LOG::LogFailure( message:"test1.B2:  Failed to select Ns.");
end if;
create object instance n1 of employee;
create object instance n2 of employee;
delete object instance n2;
n1.name = "Vijay";
for each n in ns
  if ( n.name != "Dave" ) and ( n.name != "Pete" )
    LOG::LogFailure( message:"test1.B3:  Selected incorrect Ns.");
  end if;
end for;
delete object instance n1;
select any n from instances of N where ( selected.name == "Pete" );
select one boss related by n->N[R7.'works_for'];
if ( empty boss )
  LOG::LogFailure( message:"test1.B4:  Failed to select boss.");
else
  if ( boss.name != "Chris" )
    LOG::LogFailure( message:"test1.B5:  Selected incorrect boss.");
  end if;
end if;
select any n from instances of N where ( selected.name == "Dave" );
select one m related by n->M[R7.'works_for'];
if ( empty m )
  LOG::LogFailure( message:"test1.B6:  Failed to select M.");
  if ( m.department != "MEC" )
    LOG::LogFailure( message:"test1.B7:  Selected incorrect department.");
  else
    if ( m.works_for_nID != n.nID )
      LOG::LogFailure( message:"test1.B7a:  M/N referential mismatch");
    end if;
  end if;
end if;
select any n from instances of N where ( selected.name == "Pete" );
select many ns related by n->N[R7.'manages'];
if ( cardinality ns != 2 )
  LOG::LogFailure( message:"test1.B2:  Failed to select Ns.");
end if;
for each n in ns
  if ( n.name != "Alex" ) and ( n.name != "Jenn" )
    LOG::LogFailure( message:"test1.B3:  Selected incorrect Ns.");
  end if;
end for;


//
// Test 1-1 associatives.
//
select any p from instances of P where ( selected.eyedee == "Rox" );
select one q related by p->Q[R9];
if ( q.deeeye != "Cort" )
  LOG::LogFailure( message:"test1.D1:  Selected incorrect Q.");
end if;
select any q from instances of Q where ( selected.deeeye == "Rusty" );
select one p related by q->P[R9];
if ( p.eyedee != "Bita" )
  LOG::LogFailure( message:"test1.D2:  Selected incorrect P.");
end if;
select any p from instances of P where ( selected.eyedee == "Tina" );
select one r related by p->R[R9];
if ( r.city != "Lockport" )
  LOG::LogFailure( message:"test1.D3:  Selected incorrect R.");
else
  if ( p.pID != r.pID )
    LOG::LogFailure( message:"test1.D3a:  P/R referential mismatch");
  end if;
end if;

//
// Test 1-M associatives.
//
select any s from instances of S where ( selected.s == "Rox" );
select many ts related by s->T[R10];
if ( cardinality ts != 2 )
  LOG::LogFailure( message:"test1.E1:  Incorrect number of Ts.");
end if;
for each t in ts
  if ( ( t.t != "Hannah" ) and ( t.t != "Ruby" ) )
    LOG::LogFailure( message:"test1.E2:  Incorrect T.");
  end if;
  select one s related by t->S[R10];
  if ( s.s != "Rox" )
    LOG::LogFailure( message:"test1.E3:  Incorrect S.");
  end if;
end for;
select any t from instances of T where ( selected.t == "Katrina" );
select one s related by t->S[R10];
select any u related by s->U[R10] where ( selected.s == "Aug" );
if ( empty u )
  LOG::LogFailure( message:"test1.E4:  Incorrect U.");
else
  if ( s.sID != u.sID )
    LOG::LogFailure( message:"test1.E4a:  S/U referential mismatch");
  end if;
end if;

//
// Test 1-1 reflexive associatives.
//
select any w from instances of W where ( selected.name == "Rox" );
select one husband related by w->W[R11.'is_wife_of'];
if ( husband.name != "Cort" )
  LOG::LogFailure( message:"test1.F1:  Incorrect W.");
end if;
select any w from instances of W where ( selected.name == "Jacqui" );
select one husband related by w->W[R11.'is_wife_of'];
if ( husband.name != "Sean" )
  LOG::LogFailure( message:"test1.F2:  Incorrect W.");
end if;
select any huz from instances of W where ( selected.name == "Cort" );
select one wife related by huz->W[R11.'is_husband_of'];
if ( wife.name != "Rox" )
  LOG::LogFailure( message:"test1.F3:  Incorrect W.");
end if;
select any v from instances of V where ( selected.year == 1988 );
if ( ( v.husband != "Cort" ) or ( v.wife != "Rox" ) )
  LOG::LogFailure( message:"test1.F4:  Incorrect V or referential mismatch." );
end if;

// Test friends and friendships.
// (Note that this should be symmetric reflexive, but we don't know how.)
//
select any x from instances of X where ( selected.name == "Cort" );
if ( empty x )
  LOG::LogFailure( message:"test1.X1:  Failed to select X." );
end if;
select many xs related by x->X[R12.'is_pal_of'];
cardxs = cardinality xs;
select many xs related by x->X[R12.'is_buddy_of'];
cardxs = cardxs + cardinality xs;
if ( cardxs != 5 )
  LOG::LogFailure( message:"test1.X2:  Wrong number of friends." );
end if;
select many ys from instances of Y where ( selected.pal == "Cort" )
  or ( selected.buddy == "Cort" );
if ( cardinality ys != 5 )
  LOG::LogFailure( message:"test1.Y3:  Wrong number of friends." );
end if;
// Test Sevina's friends.
select any x from instances of X where ( selected.name == "Sevina" );
if ( empty x )
  LOG::LogFailure( message:"test1.X4:  Failed to select X." );
end if;
select any x1 related by x->X[R12.'is_pal_of'];
if ( x1.name != "Rox" )
  LOG::LogFailure( message:"test1.X5:  Could not find Rox." );
end if;
select any x from instances of X where ( selected.name == "Rox" );
if ( empty x )
  LOG::LogFailure( message:"test1.X6:  Failed to select X." );
end if;
select any x1 related by x->X[R12.'is_buddy_of'];
if ( x1.name != "Sevina" )
  LOG::LogFailure( message:"test1.X6:  Could not find Sevina." );
end if;
select any y from instances of friendship;
select one x related by y->X[R12.'is_pal_of'];
if ( x.name != y.pal )
  LOG::LogFailure( message:"test1.X6a:  X/Y referential mismatch" );
end if;
select one x related by y->X[R12.'is_buddy_of'];
if ( x.name != y.buddy )
  LOG::LogFailure( message:"test1.X6b:  X/Y referential mismatch" );
end if;


//
// Test dealers and deals.
//
select any z from instances of Z where ( selected.name == "Joe" );
if ( empty z )
  LOG::LogFailure( message:"test1.Z1:  Failed to select Z." );
end if;
select many zs related by z->Z[R13.'buys_from'];
if ( cardinality zs < 2 )
  LOG::LogFailure( message:"test1.Z2:  Could not find Zs." );
end if;
select any zz from instances of deal;
select one z related by zz->Z[R13.'buys_from'];
if ( zz.buyer != z.name )
  LOG::LogFailure( message:"test1.Z2a:  Z/ZZ referential mismatch" );
end if;
select one z related by zz->Z[R13.'sells_to'];
if ( zz.seller != z.name )
  LOG::LogFailure( message:"test1.Z2b:  Z/ZZ referential mismatch" );
end if;

LOG::LogSuccess( message:"Made it to the end." );
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '3478bf0f-b428-4b52-b41a-0ce97241c99b' DO NOT EDIT THIS LINE.
private service pei::test1 () is
//
// Generate an event to be sure that b is in the correct current state.
//
select any b from instances of socket;
generate B1:go() to b;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'a20db3d4-77d0-47da-9b8c-6d6a1d4dabf2' DO NOT EDIT THIS LINE.
private service pei::test2 () is
// Do some creates and deletes to to exercise storage.
// But delete everything created.

create object instance a of plug;
delete object instance a;

create object instance a of plug;
create object instance b of socket;
relate a to b across R1;
create object instance c of dog;
create object instance d of dog_owner;
relate c to d across R2;
create object instance y of friendship;
create object instance z of dealer;

unrelate c from d across R2;
unrelate a from b across R1;

delete object instance a;
delete object instance b;
delete object instance z;
delete object instance y;
delete object instance c;
delete object instance d;

create object instance n of employee;
delete object instance n;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '888d97ee-40a0-4baa-8ca8-41c7678e8e7d' DO NOT EDIT THIS LINE.
private service pei::xit () is
ARCH::shutdown();
//! ACTIVITY END. DO NOT EDIT THIS LINE.

