-- root-types-contained: Package_c
-- BP 7.1 content: StreamData syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ VALUES ( "00000000-0000-0000-0000-000000000029",'Structured_Object',2,'SO','',"00000000-0000-0000-0000-000000000000" );
INSERT INTO O_OBJ VALUES ( "00000000-0000-0000-0000-000000000034",'Report_Data',3,'RD','',"00000000-0000-0000-0000-000000000000" );
INSERT INTO O_OBJ VALUES ( "00000000-0000-0000-0000-00000000003f",'Test_Data',4,'TD','',"00000000-0000-0000-0000-000000000000" );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-0000000001e3","00000000-0000-0000-0000-000000000029","00000000-0000-0000-0000-000000000000",'','','','Reference_SO',0,"ba5eda7a-def5-0000-0000-000000000002",'','' );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-0000000001eb","00000000-0000-0000-0000-000000000029","00000000-0000-0000-0000-0000000001e3",'','','','An_Integer',0,"ba5eda7a-def5-0000-0000-000000000002",'','' );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-0000000001f1","00000000-0000-0000-0000-000000000029","00000000-0000-0000-0000-0000000001eb",'','','','A_Real',0,"ba5eda7a-def5-0000-0000-000000000003",'','' );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-0000000001f7","00000000-0000-0000-0000-000000000029","00000000-0000-0000-0000-0000000001f1",'','','','Some_Text',0,"ba5eda7a-def5-0000-0000-000000000004",'','' );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-0000000001fd","00000000-0000-0000-0000-000000000029","00000000-0000-0000-0000-0000000001f7",'','','','A_Boolean',0,"ba5eda7a-def5-0000-0000-000000000001",'','' );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-000000000203","00000000-0000-0000-0000-000000000029","00000000-0000-0000-0000-0000000001fd",'','','','A_Colour',0,"00000000-0000-0000-0000-000000000058",'','' );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-000000000229","00000000-0000-0000-0000-000000000029","00000000-0000-0000-0000-000000000203",'','','','current_state',0,"ba5eda7a-def5-0000-0000-000000000006",'','' );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-00000000049c","00000000-0000-0000-0000-000000000034","00000000-0000-0000-0000-000000000000",'','','','Report_Data_Unique_id',0,"ba5eda7a-def5-0000-0000-000000000002",'','' );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-0000000004a4","00000000-0000-0000-0000-000000000034","00000000-0000-0000-0000-00000000049c",'','','','Reported_Domain_Number',0,"ba5eda7a-def5-0000-0000-000000000002",'','' );
INSERT INTO O_ATTR VALUES ( "00000000-0000-0000-0000-0000000004aa","00000000-0000-0000-0000-00000000003f","00000000-0000-0000-0000-000000000000",'','','','The_Test_Number',0,"ba5eda7a-def5-0000-0000-000000000002",'','' );
INSERT INTO O_ID VALUES ( 0,"00000000-0000-0000-0000-000000000029" );
INSERT INTO O_ID VALUES ( 1,"00000000-0000-0000-0000-000000000029" );
INSERT INTO O_ID VALUES ( 2,"00000000-0000-0000-0000-000000000029" );
INSERT INTO O_ID VALUES ( 0,"00000000-0000-0000-0000-000000000034" );
INSERT INTO O_ID VALUES ( 1,"00000000-0000-0000-0000-000000000034" );
INSERT INTO O_ID VALUES ( 2,"00000000-0000-0000-0000-000000000034" );
INSERT INTO O_ID VALUES ( 0,"00000000-0000-0000-0000-00000000003f" );
INSERT INTO O_ID VALUES ( 1,"00000000-0000-0000-0000-00000000003f" );
INSERT INTO O_ID VALUES ( 2,"00000000-0000-0000-0000-00000000003f" );
INSERT INTO O_OIDA VALUES ( "00000000-0000-0000-0000-0000000001e3","00000000-0000-0000-0000-000000000029",0,'' );
INSERT INTO O_OIDA VALUES ( "00000000-0000-0000-0000-00000000049c","00000000-0000-0000-0000-000000000034",0,'' );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-0000000001e3","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-0000000001eb","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-0000000001f1","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-0000000001f7","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-0000000001fd","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-000000000203","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-000000000229","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-00000000049c","00000000-0000-0000-0000-000000000034" );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-0000000004a4","00000000-0000-0000-0000-000000000034" );
INSERT INTO O_BATTR VALUES ( "00000000-0000-0000-0000-0000000004aa","00000000-0000-0000-0000-00000000003f" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-0000000001e3","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-0000000001eb","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-0000000001f1","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-0000000001f7","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-0000000001fd","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-000000000203","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-000000000229","00000000-0000-0000-0000-000000000029" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-00000000049c","00000000-0000-0000-0000-000000000034" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-0000000004a4","00000000-0000-0000-0000-000000000034" );
INSERT INTO O_NBATTR VALUES ( "00000000-0000-0000-0000-0000000004aa","00000000-0000-0000-0000-00000000003f" );
INSERT INTO O_TFR VALUES ( "00000000-0000-0000-0000-000000000209","00000000-0000-0000-0000-000000000029",'Create_Simple_Structure','',"ba5eda7a-def5-0000-0000-000000000000",0,'[] = RPT1:Start_Test[Test,"1241-0000-01-1212", "Structures", "objSO", "Construct simple structure"]

How_Many = countof {Returned_Simple_Structure}

loop_counter = How_Many + 1

Failure_Value = 0

Termination_Condition = loop_counter + 5

# Add five elements into the set

loop

   # This is supposed to be a set, therefore, stuff several
   # version of the input data into it.
   # This will be determined by the test number at the time.
   append [Object_Instance_Handle.An_Integer, \
           Object_Instance_Handle.A_Real,   \
           Object_Instance_Handle.Some_Text, \ 
           Object_Instance_Handle.A_Boolean, \
           Object_Instance_Handle.A_Colour]   \
   to {Returned_Simple_Structure}

   loop_counter = loop_counter + 1

   breakif loop_counter = Termination_Condition

endloop

How_Many_Now = countof {Returned_Simple_Structure}   


# All tests

 
[] = RPT2:Test_Passed[Object_Instance_Handle.Some_Text, Test, How_Many_Now]

',3,'',"00000000-0000-0000-0000-000000000000",2,1 );
INSERT INTO O_TFR VALUES ( "00000000-0000-0000-0000-00000000020d","00000000-0000-0000-0000-000000000029",'Decode_Simple_Structure','',"ba5eda7a-def5-0000-0000-000000000000",0,' 
[] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Structured Object Synch Service", "Decode simple data structures"]

# How many in the set
How_Many = countof {A_Structure}

Count = 1

# Look at the final entry in the list only.
if Final_Entry_Only = TRUE then

   for [the_integer, the_real, the_text, the_boolean, the_colour] in {A_Structure} do

      local_integer = the_integer
      local_real    = the_real
      local_text    = the_text
      local_boolean = the_boolean
      local_colour  = the_colour

      # Force a look at the penultimate entry in the set.
      Termination_Condition = How_Many - 1

      # Only look at the final entry
      if Count = Termination_Condition then 

         if local_integer = Instance_Handle.An_Integer and \
            local_real    = Instance_Handle.A_Real     and \
            local_text    = Instance_Handle.Some_Text  and \
            local_boolean = Instance_Handle.A_Boolean  and \
            local_colour  = Instance_Handle.A_Colour   then

            [] = RPT2:Test_Passed[Instance_Handle.Some_Text, Test, Count]

         else
  
            [] = RPT3:Test_Failed[Instance_Handle.Some_Text, Test, Count]

         endif

      endif

      Count = Count + 1

      # Don''t want to read all the entries, just all but one of them.
      # This so that we can append into the set again on the next iteration.

      breakif Count = How_Many

   endfor

# Look at all entries
else

   Has_Passed = TRUE
   Passed_Count = 0

   for [the_integer, the_real, the_text, the_boolean, the_colour] in {A_Structure} do

      local_integer = the_integer
      local_real    = the_real
      local_text    = the_text
      local_boolean = the_boolean
      local_colour  = the_colour

      if local_integer = Instance_Handle.An_Integer and \
         local_real    = Instance_Handle.A_Real     and \
         local_text    = Instance_Handle.Some_Text  and \
         local_boolean = Instance_Handle.A_Boolean  and \
         local_colour  = Instance_Handle.A_Colour   then

         Passed_Count = Passed_Count + 1

      else

         Has_Passed = FALSE
         Passed_Count = Passed_Count - 1
  
       endif

      Count = Count + 1

   endfor

   if Has_Passed = TRUE then

      [] = RPT2:Test_Passed[Instance_Handle.Some_Text, Test, Passed_Count]

   else

      [] = RPT3:Test_Failed[Instance_Handle.Some_Text, Test, Passed_Count]

   endif

endif
',3,'',"00000000-0000-0000-0000-000000000209",2,2 );
INSERT INTO O_TFR VALUES ( "00000000-0000-0000-0000-000000000212","00000000-0000-0000-0000-000000000029",'Create_Complex_Structure','',"ba5eda7a-def5-0000-0000-000000000000",0,'',3,'',"00000000-0000-0000-0000-00000000020d",0,3 );
INSERT INTO O_TFR VALUES ( "00000000-0000-0000-0000-000000000213","00000000-0000-0000-0000-000000000029",'Decode_Complex_Structure','',"ba5eda7a-def5-0000-0000-000000000000",0,'',3,'',"00000000-0000-0000-0000-000000000212",0,4 );
INSERT INTO O_TFR VALUES ( "00000000-0000-0000-0000-000000000214","00000000-0000-0000-0000-000000000029",'Create_Simple_TL_Structure','',"ba5eda7a-def5-0000-0000-000000000000",0,'[] = RPT1:Start_Test[Test,"1241-0000-01-1212", "Structures", "objSO", "Construct Type Linked simple structure"]

How_Many = countof {Returned_Simple_Structure}

loop_counter = How_Many + 1

Failure_Value = 0

Termination_Condition = loop_counter + 5

# Add five elements into the set

loop

   # This is supposed to be a set, therefore, stuff several
   # version of the input data into it.
   # This will be determined by the test number at the time.
   append [Object_Instance_Handle.An_Integer, \
           Object_Instance_Handle.A_Real,   \
           Object_Instance_Handle.Some_Text, \ 
           Object_Instance_Handle.A_Boolean]   \
   to {Returned_Simple_Structure}

   loop_counter = loop_counter + 1

   breakif loop_counter = Termination_Condition

endloop

How_Many_Now = countof {Returned_Simple_Structure}   


# All tests
   
[] = RPT2:Test_Passed[Object_Instance_Handle.Some_Text, Test, How_Many_Now]
',3,'',"00000000-0000-0000-0000-000000000213",2,5 );
INSERT INTO O_TFR VALUES ( "00000000-0000-0000-0000-000000000218","00000000-0000-0000-0000-000000000029",'Decode_Simple_TL_Structure','',"ba5eda7a-def5-0000-0000-000000000000",0,' 
[] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Structured Object Synch Service", "Decode simple TL data structures"]

# How many in the set
How_Many = countof {A_Structure}

Count = 1

# Look at the final entry in the list only.
if Final_Entry_Only = TRUE then

   for [the_integer, the_real, the_text, the_boolean] in {A_Structure} do

      local_integer = the_integer
      local_real    = the_real
      local_text    = the_text
      local_boolean = the_boolean

      # Force a look at the penultimate entry in the set.
      Termination_Condition = How_Many - 1

      # Only look at the final entry
      if Count = Termination_Condition then 

         if local_integer = Instance_Handle.An_Integer and \
            local_real    = Instance_Handle.A_Real     and \
            local_text    = Instance_Handle.Some_Text  and \
            local_boolean = Instance_Handle.A_Boolean  then

            [] = RPT2:Test_Passed[Instance_Handle.Some_Text, Test, Count]

         else
  
            [] = RPT3:Test_Failed[Instance_Handle.Some_Text, Test, Count]

         endif

      endif

      Count = Count + 1

      # Don''t want to read all the entries, just all but one of them.
      # This so that we can append into the set again on the next iteration.

      breakif Count = How_Many

   endfor

# Look at all entries
else

   Passed_Count = 0

   Local_Test_Passed = TRUE

   for [the_integer, the_real, the_text, the_boolean] in {A_Structure} do

      local_integer = the_integer
      local_real    = the_real
      local_text    = the_text
      local_boolean = the_boolean

      if local_integer = Instance_Handle.An_Integer and \
         local_real    = Instance_Handle.A_Real     and \
         local_text    = Instance_Handle.Some_Text  and \
         local_boolean = Instance_Handle.A_Boolean  then

         Passed_Count = Passed_Count + 1

      else

         Passed_Count = Passed_Count - 1
         Local_Test_Passed = FALSE 
 
       endif

      Count = Count + 1

   endfor

   if Local_Test_Passed = TRUE then

      [] = RPT2:Test_Passed[Instance_Handle.Some_Text, Test, Passed_Count]

   else

      [] = RPT3:Test_Failed[Instance_Handle.Some_Text, Test, Passed_Count]

   endif

endif
',3,'',"00000000-0000-0000-0000-000000000214",2,6 );
INSERT INTO O_TFR VALUES ( "00000000-0000-0000-0000-00000000021d","00000000-0000-0000-0000-000000000029",'Create_Simple_NTL_Structure','',"ba5eda7a-def5-0000-0000-000000000000",0,'[] = RPT1:Start_Test[Test,"1241-0000-01-1212", "Structures", "objSO", "Construct simple NTL structure"]

How_Many = countof {Returned_Simple_Structure}

loop_counter = How_Many + 1

Failure_Value = 0

Termination_Condition = loop_counter + 5

# Add five elements into the set

loop

   # This is supposed to be a set, therefore, stuff several
   # version of the input data into it.
   # This will be determined by the test number at the time.
   append [Object_Instance_Handle.An_Integer, \
           Object_Instance_Handle.A_Real,   \
           Object_Instance_Handle.Some_Text, \ 
           Object_Instance_Handle.A_Boolean]   \
   to {Returned_Simple_Structure}

   loop_counter = loop_counter + 1

   breakif loop_counter = Termination_Condition

endloop

How_Many_Now = countof {Returned_Simple_Structure}   


# All tests
   
[] = RPT2:Test_Passed[Object_Instance_Handle.Some_Text, Test, How_Many_Now]
',3,'',"00000000-0000-0000-0000-000000000218",2,7 );
INSERT INTO O_TFR VALUES ( "00000000-0000-0000-0000-000000000221","00000000-0000-0000-0000-000000000029",'Decode_Simple_NTL_Structure','',"ba5eda7a-def5-0000-0000-000000000000",0,' 

# How many in the set
How_Many = countof {A_Structure}

Count = 1

# Look at the final entry in the list only.
if Final_Entry_Only = TRUE then

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Structured Object Synch Service", "Decode simple final NTL data structure"]

   for [the_integer, the_real, the_text, the_boolean] in {A_Structure} do

      local_integer = the_integer
      local_real    = the_real
      local_text    = the_text
      local_boolean = the_boolean

      # Force a look at the penultimate entry in the set.
      Termination_Condition = How_Many - 1

      # Only look at the final entry
      if Count = Termination_Condition then 

         if local_integer = Instance_Handle.An_Integer and \
            local_real    = Instance_Handle.A_Real     and \
            local_text    = Instance_Handle.Some_Text  and \
            local_boolean = Instance_Handle.A_Boolean  then

            [] = RPT2:Test_Passed[Instance_Handle.Some_Text, Test, Count]

         else
  
            [] = RPT3:Test_Failed[Instance_Handle.Some_Text, Test, Count]

         endif

      endif

      Count = Count + 1

      # Don''t want to read all the entries, just all but one of them.
      # This so that we can append into the set again on the next iteration.

      breakif Count = How_Many

   endfor

# Look at all entries
else

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Structured Object Synch Service", "Decode simple all NTL data structures"]

   Has_Passed = TRUE
   Passed_Count = 0


   for [the_integer, the_real, the_text, the_boolean] in {A_Structure} do

      local_integer = the_integer
      local_real    = the_real
      local_text    = the_text
      local_boolean = the_boolean

      if local_integer = Instance_Handle.An_Integer and \
         local_real    = Instance_Handle.A_Real     and \
         local_text    = Instance_Handle.Some_Text  and \
         local_boolean = Instance_Handle.A_Boolean  then

         Passed_Count = Passed_Count + 1

      else

         Has_Passed   = FALSE
         Passed_Count = Passed_Count - 1

  
       endif

      Count = Count + 1

   endfor

   if Has_Passed = TRUE then

      [] = RPT2:Test_Passed[Instance_Handle.Some_Text, Test, Passed_Count]

   else

      [] = RPT3:Test_Failed[Instance_Handle.Some_Text, Test, Passed_Count]

   endif


endif
',3,'',"00000000-0000-0000-0000-00000000021d",2,8 );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000020a","00000000-0000-0000-0000-000000000209",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000020b","00000000-0000-0000-0000-000000000209",'Object_Instance_Handle',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-00000000020a",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000020c","00000000-0000-0000-0000-000000000209",'Returned_Simple_Structure',"00000000-0000-0000-0000-00000000004a",1,'',"00000000-0000-0000-0000-00000000020b",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000020e","00000000-0000-0000-0000-00000000020d",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000020f","00000000-0000-0000-0000-00000000020d",'A_Structure',"00000000-0000-0000-0000-00000000004a",0,'',"00000000-0000-0000-0000-00000000020e",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000210","00000000-0000-0000-0000-00000000020d",'Instance_Handle',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-00000000020f",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000211","00000000-0000-0000-0000-00000000020d",'Final_Entry_Only',"ba5eda7a-def5-0000-0000-000000000001",0,'',"00000000-0000-0000-0000-000000000210",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000215","00000000-0000-0000-0000-000000000214",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000216","00000000-0000-0000-0000-000000000214",'Object_Instance_Handle',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-000000000215",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000217","00000000-0000-0000-0000-000000000214",'Returned_Simple_Structure',"00000000-0000-0000-0000-00000000005b",1,'',"00000000-0000-0000-0000-000000000216",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000219","00000000-0000-0000-0000-000000000218",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000021a","00000000-0000-0000-0000-000000000218",'A_Structure',"00000000-0000-0000-0000-00000000005b",0,'',"00000000-0000-0000-0000-000000000219",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000021b","00000000-0000-0000-0000-000000000218",'Instance_Handle',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-00000000021a",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000021c","00000000-0000-0000-0000-000000000218",'Final_Entry_Only',"ba5eda7a-def5-0000-0000-000000000001",0,'',"00000000-0000-0000-0000-00000000021b",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000021e","00000000-0000-0000-0000-00000000021d",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-00000000021f","00000000-0000-0000-0000-00000000021d",'Object_Instance_Handle',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-00000000021e",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000220","00000000-0000-0000-0000-00000000021d",'Returned_Simple_Structure',"00000000-0000-0000-0000-000000000067",1,'',"00000000-0000-0000-0000-00000000021f",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000222","00000000-0000-0000-0000-000000000221",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000223","00000000-0000-0000-0000-000000000221",'A_Structure',"00000000-0000-0000-0000-000000000067",0,'',"00000000-0000-0000-0000-000000000222",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000224","00000000-0000-0000-0000-000000000221",'Instance_Handle',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-000000000223",'' );
INSERT INTO O_TPARM VALUES ( "00000000-0000-0000-0000-000000000225","00000000-0000-0000-0000-000000000221",'Final_Entry_Only',"ba5eda7a-def5-0000-0000-000000000001",0,'',"00000000-0000-0000-0000-000000000224",'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-000000000006","ba5eda7a-def5-0000-0000-000000000004",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-000000000009","00000000-0000-0000-0000-000000000006",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-00000000000c","00000000-0000-0000-0000-000000000006",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-00000000000f","ba5eda7a-def5-0000-0000-000000000002",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-000000000012","ba5eda7a-def5-0000-0000-000000000004",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-000000000015","ba5eda7a-def5-0000-0000-000000000002",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-000000000018","ba5eda7a-def5-0000-0000-000000000002",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-00000000001b","ba5eda7a-def5-0000-0000-000000000002",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-00000000001e","ba5eda7a-def5-0000-0000-000000000002",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-0000000000b1","00000000-0000-0000-0000-000000000006",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-0000000000b6","00000000-0000-0000-0000-000000000006",0,'' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-0000000000b9","00000000-0000-0000-0000-000000000006",0,'integer' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-0000000000bd","00000000-0000-0000-0000-000000000006",0,'real' );
INSERT INTO S_UDT VALUES ( "00000000-0000-0000-0000-0000000000d5","00000000-0000-0000-0000-000000000006",0,'' );
INSERT INTO EP_PKG VALUES ( "00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000002","00000000-0000-0000-0000-000000000002",'types','',0 );
INSERT INTO EP_PKG VALUES ( "00000000-0000-0000-0000-000000000021","00000000-0000-0000-0000-000000000002","00000000-0000-0000-0000-000000000002",'Struct','masl_domain',0 );
INSERT INTO EP_PKG VALUES ( "00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000002",'Struct','',0 );
INSERT INTO EP_PKG VALUES ( "00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000002",'Shared','',0 );
INSERT INTO EP_PKG VALUES ( "00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000002",'types','',0 );
INSERT INTO EP_PKG VALUES ( "00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000002",'functions','',0 );
INSERT INTO EP_PKG VALUES ( "00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000002",'scenarios','',0 );
INSERT INTO S_EDT VALUES ( "00000000-0000-0000-0000-000000000058" );
INSERT INTO S_EDT VALUES ( "00000000-0000-0000-0000-0000000000da" );
INSERT INTO S_ENUM VALUES ( "00000000-0000-0000-0000-00000000008b",'Red','',"00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-000000000000" );
INSERT INTO S_ENUM VALUES ( "00000000-0000-0000-0000-00000000008c",'Green','',"00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-00000000008b" );
INSERT INTO S_ENUM VALUES ( "00000000-0000-0000-0000-00000000008d",'Blue','',"00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-00000000008c" );
INSERT INTO S_ENUM VALUES ( "00000000-0000-0000-0000-0000000000dd",'Red','',"00000000-0000-0000-0000-0000000000da","00000000-0000-0000-0000-000000000000" );
INSERT INTO S_ENUM VALUES ( "00000000-0000-0000-0000-0000000000de",'Pink','',"00000000-0000-0000-0000-0000000000da","00000000-0000-0000-0000-0000000000dd" );
INSERT INTO S_ENUM VALUES ( "00000000-0000-0000-0000-0000000000df",'Puce','',"00000000-0000-0000-0000-0000000000da","00000000-0000-0000-0000-0000000000de" );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-00000000010b","00000000-0000-0000-0000-000000000000",'Decode_Simple_Structure','','[] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Domain synch service", "Decode simple structure"]

Count = 1

# How many in the set

How_Many = countof{Simple_Structure}

for [the_integer, the_real, the_text, the_boolean, the_colour ] in {Simple_Structure} do


   local_integer = the_integer
   local_real    = the_real
   local_text    = the_text
   local_boolean = the_boolean
   local_colour  = the_colour

   # We are only interested in the final value in the set, otherwise
   # there would be up to ten passes shown in the results file
   # for this test.

   if Count = How_Many then

      # This is the position in the set that we are interested in

      if local_integer = Object_Instance_Handle.An_Integer and \
         local_real    = Object_Instance_Handle.A_Real     and \
         local_text    = Object_Instance_Handle.Some_Text  and \
         local_boolean = Object_Instance_Handle.A_Boolean  and \
         local_colour  = Object_Instance_Handle.A_Colour   then

         [] = RPT2:Test_Passed["Structures", Test, Count]

       else
         [] = RPT3:Test_Failed["Structures", Test, Count]
       endif

   endif


   Count = Count + 1

endfor


',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,2 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-00000000011a","00000000-0000-0000-0000-000000000000",'Decode_Simple_TL_Structure','','[] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Domain synch service", "Decode simple TL structure"]

Count = 1

# How many in the set

How_Many = countof{Simple_Structure}

for [the_integer, the_real, the_text, the_boolean] in {Simple_Structure} do


   local_integer = the_integer
   local_real    = the_real
   local_text    = the_text
   local_boolean = the_boolean

   # We are only interested in the final value in the set, otherwise
   # there would be up to ten passes shown in the results file
   # for this test.

   if Count = How_Many then

      # This is the position in the set that we are interested in

      if local_integer = Object_Instance_Handle.An_Integer and \
         local_real    = Object_Instance_Handle.A_Real     and \
         local_text    = Object_Instance_Handle.Some_Text  and \
         local_boolean = Object_Instance_Handle.A_Boolean  then

         [] = RPT2:Test_Passed["Structures", Test, Count]

       else
         [] = RPT3:Test_Failed["Structures", Test, Count]
       endif

   endif


   Count = Count + 1

endfor


',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,4 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-000000000124","00000000-0000-0000-0000-000000000000",'Decode_Simple_NTL_Structure','','[] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Domain synch service", "Decode simple structure"]

Count = 1

# How many in the set

How_Many = countof{Simple_Structure}

for [the_integer, the_real, the_text, the_boolean] in {Simple_Structure} do


   local_integer = the_integer
   local_real    = the_real
   local_text    = the_text
   local_boolean = the_boolean

   # We are only interested in the final value in the set, otherwise
   # there would be up to ten passes shown in the results file
   # for this test.

   if Count = How_Many then

      # This is the position in the set that we are interested in

      if local_integer = Object_Instance_Handle.An_Integer and \
         local_real    = Object_Instance_Handle.A_Real     and \
         local_text    = Object_Instance_Handle.Some_Text  and \
         local_boolean = Object_Instance_Handle.A_Boolean  then

         [] = RPT2:Test_Passed["Structures", Test, Count]

       else
         [] = RPT3:Test_Failed["Structures", Test, Count]
       endif

   endif


   Count = Count + 1

endfor


',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,6 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-00000000012e","00000000-0000-0000-0000-000000000000",'Decode_Three_Level_Nested_Structure','','
[] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Nested structures", "Three levels of nest"]

Test_Has_Passed   = FALSE
OK_To_Proceed = FALSE
Failure_Code  = 0

How_Many = countof{One_Level_Nest}

# First compare the contents of the parameter One_Level_Nest to known datum

for [number, colour] in {One_Level_Nest} do

   if colour   = Given_Third_Level_Colour &\
      number   = Given_Third_Level_Number &\
      How_Many = How_Many_In_Third  then
      
      # The datum and the simple non-nested structure match
      OK_To_Proceed = TRUE

   else
      OK_To_Proceed = FALSE
      Failure_Code  = -1
   endif

endfor

# Simple structure matches the given data, precautionary check.
if OK_To_Proceed then

   #Since no equivalence check for structures exists in WACA, let''s ... off road

   # Bear in mind that One_Level_Nest has now been destructively read and
   # no longer exists. 

   # Decode the whole nine yards.

   # Relying on the calling routine to specify the full structure and also
   # provide all the count information means that each non-structure entry 
   # in a set must contain the same data as the previous structure.

   How_Many_First = countof{Three_Level_Nest}

   if How_Many_First = How_Many_In_First then

      # Read from top level set
      for [{Second_Level}, First_Level_Number ] in {Three_Level_Nest} do

         How_Many_Second = countof{Second_Level}

         if First_Level_Number = Given_First_Level_Number &\
            How_Many_Second    = How_Many_In_Second then

            # Read from second level intermediary set
            for [{Third_Level}, Second_Level_Number] in {Second_Level} do

               How_Many_Third = countof{Third_Level}

               if Second_Level_Number = Given_Second_Level_Number &\
                  How_Many_Third      = How_Many_In_Third then

                  # Read from bottom level third set
                  for [Third_Level_Number, Third_Level_Colour] in {Third_Level} do

                     if Third_Level_Number = Given_Third_Level_Number &\
                        Third_Level_Colour = Given_Third_Level_Colour then

                        Test_Has_Passed  = TRUE
                        Failure_Code = 0
  
                     else
                        Test_Has_Passed = FALSE
                        Failure_Has_Code = -5
                     endif

                  endfor

               else
                  Test_Has_Passed = FALSE
                  Failure_Code = -4
               endif

            endfor

         else
            Test_Has_Passed = FALSE
            Failure_Code = -3
         endif

      endfor

   else
      Failure_Code = -2
      Test_Has_Passed = FALSE
   endif

endif


if Test_Has_Passed then
   [] = RPT2:Test_Passed["Three levels of nest", Test, 0]
else
   [] = RPT3:Test_Failed["Three levels of nest", Test, Failure_Code]
endif
',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,7 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-000000000148","00000000-0000-0000-0000-000000000000",'Create_Report_Data','','# Find out of there already is one of these.
# It is not inconceivable that a report object still exists from a previous run.
# Report objects are not deleted at the end of a run, as certain events may
# still be en-queued.

old_report = find-one Report_Data

if old_report != UNDEFINED then
   delete old_report
endif

My_Report = create unique Report_Data with Reported_Domain_Number = 0

[] = RPT6:Domain_Test_Start["Structures"]
',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,8 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-00000000014c","00000000-0000-0000-0000-000000000000",'Delete_Report_Data','','[] = RPT7:Domain_Test_Finished["Structures"]

# Do not delete the Report_Data object, as there may be still events in
# the queue.',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,9 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-000000000150","00000000-0000-0000-0000-000000000000",'Receive_Structure_IH',' Receive a structure containing and IH as a component of that structure.
','[] = RPT1:Start_Test[This_Test_Number,"1241-0000-01-1216", "Structures", "Structure and IH", Testing_For]
[] = RPT8:Specify_Requid[This_Test_Number, "1101-0000-01-0140"]

How_Many_In_Structure = countof {Input_Structure}

if How_Many_In_Structure = Number_Of_Elements then

   # We got as many as we were expecting. Now look and see that the latest
   # one in the structure has the same unique attribute as the parameter.

   # NB This would be real easy if ''find'' operations where supported for sets,
   #    but, tough luck, they aren''t.

   Result_Found = FALSE
   Bean_Counter = 0
   for [Dereferenced_IH] in {Input_Structure} do

      if Dereferenced_IH != UNDEFINED then
         Bean_Counter = Bean_Counter + 1
      endif

      # Found the one we are interested in. Should be the final element in the structure.
      if Bean_Counter = Number_Of_Elements then

         if Dereferenced_IH.Reference_SO = Unique_Identifier_Of_IH then
            Result_Found = TRUE
         endif

         # Bail out of the loop. 
         break
 
      endif

   endfor

   if Result_Found then
      [] = RPT2:Test_Passed[Testing_For, This_Test_Number, Unique_Identifier_Of_IH]
   else
      [] = RPT3:Test_Failed["Unmatched IH identifier ", This_Test_Number, Unique_Identifier_Of_IH]
   endif

else
 
   [] = RPT3:Test_Failed["Inconsistent number of elements", This_Test_Number, How_Many_In_Structure]


endif
',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,1 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-00000000015e","00000000-0000-0000-0000-000000000000",'Receive_Empty_Structure_IH','','[] = RPT1:Start_Test[Test_Number, "1241-0000-01-1216", "Structures", "Receive Empty Structure", Testing_For]

How_Many_In_Structure = countof{Empty_Structure}

Bean_Counter = 0

for [An_IH] in {Empty_Structure} do

   Bean_Counter = Bean_Counter + 1

endfor

if Bean_Counter = 0 & \
   How_Many_In_Structure = 0 then

   Structure_Is_Empty = TRUE

else

   Structure_Is_Empty = FALSE

endif

if Inserted_IH != UNDEFINED then

   append [Inserted_IH] to {Filled_Structure}

   if Structure_Is_Empty then

      [] = RPT2:Test_Passed[Testing_For, Test_Number, Bean_Counter]

   else

      [] = RPT3:Test_Failed["Structure was not empty", Test_Number, Bean_Counter]

   endif

else

   [] = RPT3:Test_Failed["IH does not exist", Test_Number, -1]

endif
',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,3 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-00000000016c","00000000-0000-0000-0000-000000000000",'Test_The_Structure','','for [the_integer, the_color] in {Structure_Input} do

   local_integer = the_integer
   local_color  = the_color

   if local_color = ''Red'' then
      local_integer = 200
      local_color   of Colour_Type = ''Blue''
   endif   

endfor

append [local_integer, local_color] to {The_Return_Structure}
',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,5 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-000000000176","00000000-0000-0000-0000-000000000000",'Check_Returning_Structure','','
if Integer_Input = 100 then
   Local_Integer = 200 
endif

if Real_Input = 1.0 then
   Local_Real = 2.0
endif

if String_Input = "Structures Test" then
  Local_String = "Test Complete"
endif

if UDT_Input = ''Blue'' then
   Local_UDT of Colour_Type = ''Green''
endif

append [Local_Integer, Local_Real, Local_String, Local_UDT] to {Returning_Structure}',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,10 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001cc","00000000-0000-0000-0000-000000000000",'Simple_Structure_Scenario',' Simple Structure Scenario
','# Set up scenario test data.
Test_Has_Passed = FALSE

My_Test_Data = find-one Test_Data
Test = My_Test_Data.The_Test_Number

#--------------------------------------------------------------------------
# Test 1 - Report the number of User Defined Types used
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Reported No UDTs", "Obtain No of UDTs Used"]

   Reported_No_UDT = 0
   Expected_No_UDT = 0

   $INLINE
      Reported_No_UDT = 20;
      fprintf(stderr,"Checking number of UDTs. Hardcoded to %d\n", Reported_No_UDT);
   $ENDINLINE

   #$ADA_INLINE
      #with Ada.Text_IO;
      #
      #with Struct_Domain_Types;
      #Reported_No_UDT := Struct_Domain_Types.Types_And_Subtypes_Count;
   #$END_ADAINLINE

   # This is the hardcoded expected number of user defined types constant.
   # If any more UDT''s are defined for this domain, this counter MUST be set accordingly.
   # Failure to do this will cause this test to fail in an ADA run.

   Expected_No_UDT = 20

   if Reported_No_UDT = Expected_No_UDT then
      [] = RPT2:Test_Passed["Report No UDTs", Test, Reported_No_UDT]
   else 
      [] = RPT3:Test_Failed["Report No UDTs", Test, Expected_No_UDT]
   endif

# End Test 1

#--------------------------------------------------------------------------
# Test 2 -  Setup Test Data
#           Basic ''APPEND'' operation tests 
#           This test shall prove that a set is created empty.
#--------------------------------------------------------------------------

   Test = Test + 1

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Simple Scenario", "Create empty structure"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0117"]

   {Empty_Set} is Simple_Structure_Type

   Naught = countof {Empty_Set}

   if Naught = 0 then 
      [] = RPT2:Test_Passed["Scenario", Test, 0]
   else
      [] = RPT3:Test_Failed["Scenario", Test, Naught]
   endif

# End Test 2

#--------------------------------------------------------------------------
# Test 3 - Add some data into the set.
#--------------------------------------------------------------------------

   Test = Test + 1

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Simple Scenario", "Add first structure to set"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0117"]

   A_First_Local_Colour  of Colour_Type = ''Red''
   A_Second_Local_Colour of Colour_Type = ''Blue''

   A_First_Local_Number  = 100
   A_First_Local_Real    = 100.0
   A_First_Local_String  = "Hello Good Evening and Welcome"
   A_First_Local_Boolean = TRUE

   append [A_First_Local_Number, A_First_Local_Real, A_First_Local_String, A_First_Local_Boolean, A_First_Local_Colour] to {Empty_Set}

   One = countof {Empty_Set}

   if One = 1 then
      [] = RPT2:Test_Passed["Scenario", Test, One]
   else
      [] = RPT3:Test_Failed["Scenario", Test, One]
   endif

# End Test 3

#--------------------------------------------------------------------------
# Test 4 - Add some more data into the set.
#--------------------------------------------------------------------------

   Test = Test + 1

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Simple Scenario", "Add second structure to set"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0117"]

   A_Second_Local_Number  = 200
   A_Second_Local_Real    = 200.0
   A_Second_Local_String  = "Thankyou and Goodnight"
   A_Second_Local_Boolean = FALSE

   append [A_Second_Local_Number, A_Second_Local_Real, A_Second_Local_String, A_Second_Local_Boolean, A_Second_Local_Colour] to {Empty_Set}

   Two = countof {Empty_Set}

   if Two = 2 then
      [] = RPT2:Test_Passed["Scenario", Test, Two]
   else
      [] = RPT3:Test_Failed["Scenario", Test, Two]
   endif

# End Test 4

#--------------------------------------------------------------------------
# Test 5 -  Read the data back
#           The Queue is implemented as a FIFO, so read it back as such.
#           This test will need to change should this implementation ever
#           change. This test will fail if this happens.
#--------------------------------------------------------------------------

   Test = Test + 1
   
   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Simple Scenario", "Read back structure from set"]
   Local_Test_Passed = FALSE

   How_Many = countof {Empty_Set}
   if How_Many = 2 then
      Counter = 1

      for [A_Read_Number, A_Read_Real, A_Read_String, A_Read_Boolean, A_Read_Colour] in {Empty_Set} do

         if Counter = 1 and A_Read_Number  = A_First_Local_Number  and \
                            A_Read_Real    = A_First_Local_Real    and \
                            A_Read_String  = A_First_Local_String  and \
                            A_Read_Boolean = A_First_Local_Boolean and \
                            A_Read_Colour  = A_First_Local_Colour  then

            Local_Test_Passed = TRUE
         else 

            if Counter = 2 and A_Read_Number     = A_Second_Local_Number  and \
                               A_Read_Real       = A_Second_Local_Real    and \
                               A_Read_String     = A_Second_Local_String  and \
                               A_Read_Boolean    = A_Second_Local_Boolean and \
                               A_Read_Colour     = A_Second_Local_Colour  and \
                               Local_Test_Passed = TRUE  then

               [] = RPT2:Test_Passed["Simple Scenario", Test, A_Read_Number]
            else
               [] = RPT3:Test_Failed["Simple Scenario", Test, A_Read_Number]
            endif

         endif

         Counter = Counter + 1

      endfor

   else
      [] = RPT3:Test_Failed["Scenario", Test, How_Many]
   endif

# End Test 5

#--------------------------------------------------------------------------
# Test 6 - Read the data back again
#          Prove that reading a set of structures does not change it
#--------------------------------------------------------------------------

   Test = Test + 1
      
   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Simple Scenario", "Prove non-destructive read"]

   Local_Test_Passed = FALSE

   How_Many = countof {Empty_Set}

   if How_Many = 2 then
      Counter = 1

      for [A_Read_Number, A_Read_Real, A_Read_String, A_Read_Boolean, A_Read_Colour] in {Empty_Set} do

         if Counter = 1 and A_Read_Number  = A_First_Local_Number  and \
                            A_Read_Real    = A_First_Local_Real    and \
                            A_Read_String  = A_First_Local_String  and \
                            A_Read_Boolean = A_First_Local_Boolean and \
                            A_Read_Colour  = A_First_Local_Colour  then
 
            Local_Test_Passed = TRUE

         else 

            if Counter = 2 and A_Read_Number     = A_Second_Local_Number  and \
                               A_Read_Real       = A_Second_Local_Real    and \
                               A_Read_String     = A_Second_Local_String  and \
                               A_Read_Boolean    = A_Second_Local_Boolean and \
                               A_Read_Colour     = A_Second_Local_Colour  and \
                               Local_Test_Passed = TRUE  then

               [] = RPT2:Test_Passed["Scenario", Test, A_Read_Number]
            else
               [] = RPT3:Test_Failed["Scenario", Test, A_Read_Number]
            endif

         endif

         Counter = Counter + 1

      endfor

   else
      [] = RPT3:Test_Failed["Scenario", Test, How_Many]
   endif

# End Test 6

#--------------------------------------------------------------------------
# Test 7 - Call object based synch service to create a data structure, 
#          return it and then confirm that it was created correctly.
#          This test creates a new return list for each test, so the 
#          structure is always empty when we start.
#--------------------------------------------------------------------------

   Test = Test + 1
   Termination_Condition = Test + 5

   A_Real_Number = 1.0
   
   # Create a new structure object.
   {Returned_Simple_Structure_1} is Simple_Structure_Type

   struct_1 = create Structured_Object with Reference_SO  = Test                    & \
                                            Some_Text     = "Construct a structure" & \
                                            An_Integer    = Test                    & \
                                            A_Real        = A_Real_Number           &\
                                            A_Boolean     = TRUE                    &\
                                            A_Colour      = ''Green''                 &\
                                            Current_State = ''Idle''



   [{Returned_Simple_Structure_1}] = SO1:Create_Simple_Structure[Test, struct_1]

# End Test 7

#--------------------------------------------------------------------------
# Test 8
#--------------------------------------------------------------------------

   Test = Test + 1

   [] = SO2:Decode_Simple_Structure[Test, {Returned_Simple_Structure_1}, struct_1, FALSE]

   delete struct_1

# End Test 8

#--------------------------------------------------------------------------
# Test 9 - Call object based synch service to create a data structure, 
#          return it and then confirm that it was created correctly.
#          This test uses the same return parameter for all tests, so the 
#          results are appended on to the old return structure.
#
#          This test will examine what happens when an emptied set is 
#          reused.
#          The set will be emptied by the Decode_Simple_Structure service, 
#          and then written to again by the next iteration of the 
#          Create_Simple_Structure.
#
#          It is understood that for WACA 3.0.0 reading the final entry 
#          from a set will cause that set to be deleted. Subsequent appends
#          to that set will cause a fatal crash.
#
#          This is no longer the case for subsequent issues. However,  the
#          test still has some relevance, as it proves that structures can 
#          be partially read from, and then appended to again.
#--------------------------------------------------------------------------

   Test = Test + 1

   Termination_Condition = Test + 10

   A_Real_Number = 1.0

   {Returned_Simple_Structure_2} is Simple_Structure_Type

   loop
      # Create a couple of structured objects
      struct_2 = create Structured_Object with Reference_SO  = Test                    &\
                                               Some_Text     = "Construct a structure" &\
                                               An_Integer    = Test                    &\
                                               A_Real        = A_Real_Number           &\
                                               A_Boolean     = FALSE                   &\
                                               A_Colour      = ''Green''                 &\
                                               Current_State = ''Idle''

      a_structured_instance_2 = find-one Structured_Object where Reference_SO = Test

      # Create a new structure object each time, otherwise the same
      # structure will be appended to each iteration.
      [{Returned_Simple_Structure_2}] = SO1:Create_Simple_Structure[Test, a_structured_instance_2]

      Test = Test + 1

      [] = SO2:Decode_Simple_Structure[Test, {Returned_Simple_Structure_2}, a_structured_instance_2, TRUE]

      # Delete the object now we''ve done with it.
      delete a_structured_instance_2

      Test = Test + 1

      breakif Test = Termination_Condition

   endloop

# End Test 9

#--------------------------------------------------------------------------
# Test 10 - Define a test which passes a single structure to an instance 
#           through a generated event.
#--------------------------------------------------------------------------

   A_Real_Number = 1.0

   struct_3 = create Structured_Object with Reference_SO  = Test                        &\
                                            Some_Text     = "generate simple structure" &\
                                            An_Integer    = Test                        &\
                                            A_Real        = A_Real_Number               &\
                                            A_Boolean     = FALSE                       &\ 
                                            A_Colour      = ''Green''                     &\
                                            Current_State = ''Idle''

   # Create a simple structure and pass it in to the instance Simple_F1
   {Simple_Object_Structure_3} is Simple_Structure_Type

   append [struct_3.Reference_SO, \
          struct_3.A_Real,        \
          struct_3.Some_Text,     \
          struct_3.A_Boolean,     \
          struct_3.A_Colour ] to {Simple_Object_Structure_3}

   generate SO1:Start_Simple(Test, {Simple_Object_Structure_3} ) to struct_3

# End Test 10

#--------------------------------------------------------------------------
# Test 11 - Perform the same test again, except this time use a set of 
#           structures with more than one set in it.
#--------------------------------------------------------------------------

   Test = Test + 1

   A_Real_Number = 1.0

   struct_4 = create Structured_Object with Reference_SO  = Test                        &\
                                            Some_Text     = "generate simple structure" &\
                                            An_Integer    = Test                        &\
                                            A_Real        = A_Real_Number               &\
                                            A_Boolean     = FALSE                       &\
                                            A_Colour      = ''Green''                     &\
                                            Current_State = ''Idle''

   {Simple_Object_Structure_4} is Simple_Structure_Type

   Termination_Condition = 10
   Counter = 0

   loop
      append [struct_4.An_Integer, \
              struct_4.A_Real,     \
              struct_4.Some_Text,  \
              struct_4.A_Boolean,  \
              struct_4.A_Colour] to {Simple_Object_Structure_4}

      Counter = Counter + 1

      breakif Counter = Termination_Condition

   endloop

   generate SO1:Start_Simple(Test, {Simple_Object_Structure_4} ) to struct_4

# End Test 11

#--------------------------------------------------------------------------
# Test 12 - Pass in the simple structure into a domain based synchronous 
#           service.
#--------------------------------------------------------------------------

   Test = Test + 1

   struct_5 = create Structured_Object with Reference_SO  = Test                         &\
                                            Some_Text     = "Domain based synch service" &\
                                            An_Integer    = Test                         &\
                                            A_Real        = 2.0                          &\
                                            A_Boolean     = TRUE                         &\
                                            A_Colour      = ''Green''                      &\
                                            Current_State = ''Idle''

   {Simple_Object_Structure_5} is Simple_Structure_Type

   Termination_Condition = 10
   Counter = 1

   loop
      append [struct_5.An_Integer, \
              struct_5.A_Real,     \
              struct_5.Some_Text,  \
              struct_5.A_Boolean,  \
              struct_5.A_Colour] to {Simple_Object_Structure_5}

      Counter = Counter + 1

      breakif Termination_Condition = Counter

   endloop

   # Invoke domain based synch. service
   [] = Struct2::Decode_Simple_Structure[Test, {Simple_Object_Structure_5}, struct_5]

   delete struct_5

# End Test 12

#--------------------------------------------------------------------------

Test = Test + 1

My_Test_Data.The_Test_Number = Test
',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,1 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001ce","00000000-0000-0000-0000-000000000000",'Complex_Structure_Scenario',' Complex Structure Scenario
','My_Test_Data = find-one Test_Data

Test = My_Test_Data.The_Test_Number

Zero = 0

#--------------------------------------------------------------------------
# Test 1
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "Create empty structure"]

   {Outer_Set} is Complex_UDT_Structure_Type

   Nought = countof {Outer_Set}

   if Nought = Zero then
      [] = RPT2:Test_Passed["Create empty structure", Test, 0]
   else
      [] = RPT3:Test_Failed["Create empty structure", Test, Nought]
   endif

   Test = Test + 1

# End Test 1

#--------------------------------------------------------------------------
# Test 2 - Add some data into the set.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "Add data into structure"]

   local_integer       = 10
   local_real          = 10.0
   local_basic_integer = 101

   local_colour of Colour_Type = ''Red''

   {Inner_Set} is UDT_Structure_Type

   append [local_integer, local_real] to {Inner_Set}

   append [local_integer, local_real, {Inner_Set}, local_basic_integer, local_colour] to {Outer_Set}

   number_in_inner_set = countof {Inner_Set}
   number_in_outer_set = countof {Outer_Set}

   if number_in_inner_set = 1 then

      if number_in_outer_set = 1 then 
         [] = RPT2:Test_Passed["Add data into structure", Test, 0]
      else
         [] = RPT3:Test_Failed["Add data into structure", Test, number_in_outer_set]
      endif

   else
      [] = RPT3:Test_Failed["Add data into structure", Test, number_in_inner_set]
   endif

   Test = Test + 1

# End Test 2

#--------------------------------------------------------------------------
# Test 3 - Add a second entry into both sets
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "Add more data into inner and outer structures"]

   local_integer       = 20
   local_real          = 20.0
   local_basic_integer = 201

   local_colour of Colour_Type = ''Blue''

   append [local_integer, local_real] to {Inner_Set}
   append [local_integer, local_real, {Inner_Set}, local_basic_integer, local_colour] to {Outer_Set}

   number_in_inner_set = countof {Inner_Set}
   number_in_outer_set = countof {Outer_Set}

   if number_in_inner_set = 2 then
  
      if number_in_outer_set = 2 then 
         [] = RPT2:Test_Passed["Add more data into structure", Test, 0]
      else
         [] = RPT3:Test_Failed["Add more data into structure", Test, number_in_outer_set]
      endif

   else
      [] = RPT3:Test_Failed["Add more data into structure", Test, number_in_inner_set]
   endif

   Test = Test + 1

# End Test 3

#--------------------------------------------------------------------------
#  Test 4 - Add a new inner set into position 3 of the outer set.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "Add new inner structure into outer structure"]

   local_integer       = 30
   local_real          = 30.0
   local_basic_integer = 301
   local_colour of Colour_Type = ''Green''

   {New_Inner_Set} is UDT_Structure_Type

   append [local_integer, local_real] to {New_Inner_Set}
   append [local_integer, local_real, {New_Inner_Set}, local_basic_integer, local_colour] to {Outer_Set}

   number_in_inner_set = countof {New_Inner_Set}
   number_in_outer_set = countof {Outer_Set}

   if number_in_inner_set = 1 then

      if number_in_outer_set = 3 then 
         [] = RPT2:Test_Passed["Add more data into structure", Test, 0]
      else
         [] = RPT3:Test_Failed["Add more data into structure", Test, number_in_outer_set]
      endif

   else
      [] = RPT3:Test_Failed["Add more data into structure", Test, number_in_inner_set]
   endif

   Test = Test + 1

# End Test 4

#--------------------------------------------------------------------------
# Test 5 - Decode all sets of structures
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "Decode structures"]

   {decoded_inner_structure} is UDT_Structure_Type

   number_in_both_structures = 0
   total_value = 0

   number_in_outer_set = countof {Outer_Set}

   number_in_both_structures = number_in_outer_set

   for [this_integer, this_real, {decoded_inner_structure}, this_basic_integer, this_colour] in {Outer_Set} do
      total_value               = total_value + this_integer
      number_in_inner_set       = countof {decoded_inner_structure}
      number_in_both_structures = number_in_inner_set + number_in_both_structures

      for [this_inner_integer, this_inner_real] in {decoded_inner_structure} do
         total_value = total_value + this_inner_integer
      endfor

   endfor

   if total_value = 130 then
      [] = RPT2:Test_Passed["Decode structures", Test, number_in_both_structures]
   else
      [] = RPT3:Test_Failed["Decode structures", Test, number_in_both_structures]
   endif

   Test = Test + 1

# End Test 5

#--------------------------------------------------------------------------
# Test 6 - Since we are no longer labouring under the destructive read 
#          restrictions, it would be prudent to check that all structures 
#          are still current in all sets.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "And again"]

   {empty_decoded_inner_structure} is UDT_Structure_Type

   number_in_both_structures = 0
   total_value               = 0
   number_in_outer_set       = countof {Outer_Set}
   number_in_both_structures = number_in_outer_set

   for [this_integer, this_real, {empty_decoded_inner_structure}, this_basic_integer, this_colour] in {Outer_Set} do
      total_value               = total_value + this_integer
      number_in_inner_set       = countof {empty_decoded_inner_structure}
      number_in_both_structures = number_in_inner_set + number_in_both_structures

      for [this_inner_integer, this_inner_real] in {empty_decoded_inner_structure} do
         total_value = total_value + this_inner_integer
      endfor

   endfor

   if total_value = 130 then
      [] = RPT2:Test_Passed["And again", Test, number_in_both_structures]
   else
      [] = RPT3:Test_Failed["And again", Test, number_in_both_structures]
   endif

   Test = Test + 1

# End Test 6

#--------------------------------------------------------------------------
# Test 7 - Having established how sets of structures are contained in a set 
#          of structures, examine how the data is held, deep or shallow 
#          copy. To achieve this, the test shall add on entry the the inner 
#          & outer sets to check how that addition has affected the other 
#          sets in the outer set that point to it.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "Deep or shallow copy"]

   local_integer       = 40
   local_real          = 40.0
   local_basic_integer = 401

   local_colour of Colour_Type = ''Red''

   append [local_integer, local_real] to {Inner_Set}

   append [local_integer, local_real, {Inner_Set}, local_basic_integer, local_colour] to {Outer_Set}

   # Having added a third entry onto the inner and and a fourth to the outer set, 
   # have a look to see if the earlier entries in the outer set point to the latest version 
   # of the inner set, ie. outer_set(1).{inner_set} = inner_set(4). If this is the case then 
   # we have a shallow copy, otherwise if outer_set(1).{inner_set] = inner_set(1) then we have a deep copy.

   # A deep copy is what is required here.
   {fresh_decoded_inner_structure} is UDT_Structure_Type

   A_Counter    = 0
   Passed_Count = 0
 
   {fresh_decoded_inner_structure} is UDT_Structure_Type

   for [this_integer, this_real, {fresh_decoded_inner_structure}, this_basic_integer, this_colour] in {Outer_Set} do
      A_Counter          = A_Counter + 1
      Number_In_This_Set = countof{fresh_decoded_inner_structure}

      if A_Counter = 1 and Number_In_This_Set = 1 then
         Passed_Count = Passed_Count + 1        
      else

         if A_Counter = 2 and Number_In_This_Set = 2 then
            Passed_Count = Passed_Count + 1        
         else

            if A_Counter = 3 and Number_In_This_Set = 1 then
               Passed_Count = Passed_Count + 1        
            else

               if A_Counter = 4 and Number_In_This_Set = 3 then
                  Passed_Count = Passed_Count + 1        
               endif

            endif

         endif

      endif

   endfor

   number_in_outer_set = countof {Outer_Set}

   # This test has proved that first structure of the outer set of structures contains the inner set(a)  
   # with 1 structure and that the second structure of the outer set contains the inner set(a) with two 
   # structures, the third structure of the outer set contains a new inner set(b) with one structure and 
   # finally, the fourth structure of the outer set contains the inner set (a) now with three structures.
   # Exactly as it was set up.

   # A shallow copy would have shown that the first structure in the outer set had an 
   # inner structure with three structures.

   if Passed_Count = number_in_outer_set then
      [] = RPT2:Test_Passed["DEEP copy", Test, 0]
   else
      [] = RPT3:Test_Failed["SHALLOW copy", Test, Passed_Count]
   endif

   Test = Test + 1

# End Test 7

#--------------------------------------------------------------------------
# Test 8 - Having proved that each outer set contains the requisite number 
#          of inner sets, now show that the inner set is actually the inner
#          set we expected to see.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "Compare contents of inner and outer structures"]

   {another_fresh_decoded_inner_structure} is UDT_Structure_Type

   A_Counter = 0
   Total_Number_Of_Inner_Structures = 0

   Inner_Count  = 0
   Passed_Count = 0

   for [this_integer, this_real, {another_fresh_decoded_inner_structure}, this_basic_integer, this_colour] in {Outer_Set} do
      Inner_Count = 0
      A_Counter   = A_Counter + 1

      Number_In_This_Set = countof {another_fresh_decoded_inner_structure}

      Total_Number_Of_Inner_Structures =Total_Number_Of_Inner_Structures + Number_In_This_Set

      for [inner_integer, inner_real] in {another_fresh_decoded_inner_structure} do
         Inner_Count = Inner_Count + 1

         if A_Counter = 1 and Number_In_This_Set = 1 then

            if Inner_Count = 1 and (inner_integer = 10 and inner_real = 10.0) then
               Passed_Count = Passed_Count + 1        
            endif

         else

            if A_Counter = 2 and Number_In_This_Set = 2 then

               if (Inner_Count = 1 and (inner_integer = 10 and inner_real = 10.0)) or \ 
                  (Inner_Count = 2 and (inner_integer = 20 and inner_real = 20.0)) then

                  Passed_Count = Passed_Count + 1        
 
               endif
   
            else

               if A_Counter = 3 and Number_In_This_Set = 1 then

                  if Inner_Count = 1 and (inner_integer = 30 and inner_real = 30.0) then 
                     Passed_Count = Passed_Count + 1        
                  endif

               else

                  if A_Counter = 4 and Number_In_This_Set = 3 then

                     if (Inner_Count = 1 and (inner_integer = 10 and inner_real = 10.0)) or \ 
                        (Inner_Count = 2 and (inner_integer = 20 and inner_real = 20.0)) or \
                        (Inner_Count = 3 and (inner_integer = 40 and inner_real = 40.0)) then

                        Passed_Count = Passed_Count + 1        
                     endif

                  endif

               endif

            endif

         endif

      endfor

   endfor

   if Passed_Count = Total_Number_Of_Inner_Structures then
      [] = RPT2:Test_Passed["DEEP copy", Test, Total_Number_Of_Inner_Structures]
   else
      [] = RPT3:Test_Failed["SHALLOW copy", Test, Passed_Count]
   endif

   Test = Test + 1

# End Test 8

#--------------------------------------------------------------------------
# Test 9 - Show what happens when two outer structures point to the same 
#          inner stucture.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "Compare contents of outer structures"]

   {First_Outer_Set}  is Complex_UDT_Structure_Type
   {Second_Outer_Set} is Complex_UDT_Structure_Type
   {Common_Inner_Set} is UDT_Structure_Type

   local_integer       = 10
   local_real          = 10.0
   local_basic_integer = 101
   local_colour of Colour_Type = ''Red''

   append [local_integer,local_real] to {Common_Inner_Set}

   append [local_integer, local_real, {Common_Inner_Set}, local_basic_integer, local_colour] to {First_Outer_Set}
   append [local_integer, local_real, {Common_Inner_Set}, local_basic_integer, local_colour] to {Second_Outer_Set}

   # Now add a new structure to the common inner set
   local_integer       = 20
   local_real          = 20.0
   local_basic_integer = 201

   local_colour of Colour_Type = ''Blue''

   append [local_integer,local_real] to {Common_Inner_Set}

   # Add this new set of structures to the second outer set, but not the first.
   append [local_integer, local_real, {Common_Inner_Set}, local_basic_integer, local_colour] to {Second_Outer_Set}

   # Now add a new structure to the inner set
   local_integer       = 30
   local_real          = 30.0
   local_basic_integer = 301

   local_colour of Colour_Type = ''Green''

   append [local_integer,local_real] to {Common_Inner_Set}

   # Add this new set of structures to the first outer set, but not the second
   append [local_integer, local_real, {Common_Inner_Set}, local_basic_integer, local_colour] to {First_Outer_Set}

   # So, what we have is two outer sets of structures, both with a common first inner set, but different second inner
   # structures.

   {First_Inner_Set}  is UDT_Structure_Type

   First_Total_Count = 0

   for [this_integer, this_real, {First_Inner_Set}, this_basic_integer, this_colour] in {First_Outer_Set} do
      First_Total_Count = First_Total_Count + this_integer

      for [inner_integer, inner_real] in {First_Inner_Set} do
         First_Total_Count = First_Total_Count + inner_integer
      endfor

   endfor

   {Second_Inner_Set} is UDT_Structure_Type

   Second_Total_Count = 0
  
   for [this_integer, this_real, {Second_Inner_Set}, this_basic_integer, this_colour] in {Second_Outer_Set} do
      Second_Total_Count = Second_Total_Count + this_integer

      for [inner_integer, inner_real] in {Second_Inner_Set} do
         Second_Total_Count = Second_Total_Count + inner_integer
      endfor

   endfor

   if First_Total_Count = 110 and Second_Total_Count = 70 then
      [] = RPT2:Test_Passed["DEEP copy", Test, Total_Number_Of_Inner_Structures]
   else
      [] = RPT3:Test_Failed["SHALLOW copy", Test, First_Total_Count]
   endif

   Test = Test + 1

# End Test 9

#--------------------------------------------------------------------------
# Test 10
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Complex Scenario", "Append an empty structure"]

   # Append an empty simple structures to a outer structure.
   {Empty_Structure} is UDT_Structure_Type
   {Outer_Structure} is Complex_UDT_Structure_Type

   append [local_integer, local_real, {Empty_Structure}, local_basic_integer, local_colour] to {Outer_Structure}

   Number_In_Outer_Structures   = countof {Outer_Structure}
   Number_In_Empty_Structure    = countof {Empty_Structure}

   if Number_In_Outer_Structures   =1 & Number_In_Empty_Structure    = 0 then
      [] = RPT2:Test_Passed["Append empty structure to complex structure", Test, Number_In_Empty_Structure]
   else
      [] = RPT3:Test_Failed["Append empty structure to complex structure", Test, Number_In_Empty_Structure]
   endif

#--------------------------------------------------------------------------

Test = Test + 1

My_Test_Data.The_Test_Number = Test
',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,2 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001d0","00000000-0000-0000-0000-000000000000",'Simple_Type_Linked_Structure_Scenario',' Simple Type Linked Structure Scenario
','#--------------------------------------------------------------------------
# Setup Test Data
#
# TYPE LINKED Simple Structures
#--------------------------------------------------------------------------

My_Test_Data = find-one Test_Data
Test = My_Test_Data.The_Test_Number

#--------------------------------------------------------------------------
# Test 1 - Basic ''APPEND'' operation tests
#          This test shall prove that a set is created empty.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Create empty TL structure"]

   {TL_Empty_Set} is Type_Linked_Simple_Structure_Type

   Naught = countof {TL_Empty_Set}

   if Naught = 0 then 
      [] = RPT2:Test_Passed["Scenario", Test, 0]
   else
      [] = RPT3:Test_Failed["Scenario", Test, Naught]
   endif

   Test = Test + 1

# End Test 1

#--------------------------------------------------------------------------
# Test 2 - Add some data into the set
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Add first TL structure to set"]

   A_First_Local_Number  = 100
   A_First_Local_Real    = 100.0
   A_First_Local_String  = "Hello Good Evening and Welcome"
   A_First_Local_Boolean = TRUE

   append [A_First_Local_Number, A_First_Local_Real, A_First_Local_String, A_First_Local_Boolean] to {TL_Empty_Set}

   One = countof {TL_Empty_Set}

   if One = 1 then
      [] = RPT2:Test_Passed["Scenario", Test, One]
   else
      [] = RPT3:Test_Failed["Scenario", Test, One]
   endif

   Test = Test + 1

# End  Test 2

#--------------------------------------------------------------------------
# Test 3 - Add some more data into the set.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Add second TL structure to set"]

   A_Second_Local_Number  = 200
   A_Second_Local_Real    = 200.0
   A_Second_Local_String  = "Thankyou and Goodnight"
   A_Second_Local_Boolean = FALSE

   append [A_Second_Local_Number, A_Second_Local_Real, A_Second_Local_String, A_Second_Local_Boolean] to {TL_Empty_Set}

   Two = countof {TL_Empty_Set}

   if Two = 2 then
      [] = RPT2:Test_Passed["Scenario", Test, Two]
   else
      [] = RPT3:Test_Failed["Scenario", Test, Two]
   endif

   Test = Test + 1

# End Test 3

#--------------------------------------------------------------------------
# Test 4 - Read the data back
#          The Queue is implemented as a FIFO, so read it back as such.
#          This test will need to change should this implementation ever
#          change. This test will fail if this happens.
#--------------------------------------------------------------------------
   
   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Read back TL structure from set"]

   Counter = 1

   Local_Test_Passed = FALSE

   for [A_Read_Number, A_Read_Real, A_Read_String, A_Read_Boolean] in {TL_Empty_Set} do

      if Counter = 1 and A_Read_Number  = A_First_Local_Number  and \
                         A_Read_Real    = A_First_Local_Real    and \
                         A_Read_String  = A_First_Local_String  and \
                         A_Read_Boolean = A_First_Local_Boolean then

        Local_Test_Passed = TRUE

      else

         if Counter = 2 and A_Read_Number  = A_Second_Local_Number  and \
                            A_Read_Real    = A_Second_Local_Real    and \
                            A_Read_String  = A_Second_Local_String  and \
                            A_Read_Boolean = A_Second_Local_Boolean and \
                            Local_Test_Passed = TRUE then

            [] = RPT2:Test_Passed["Scenario", Test, A_Read_Number]
         else
            [] = RPT3:Test_Failed["Scenario", Test, A_Read_Number]
         endif

      endif

      Counter = Counter + 1

   endfor

   Test = Test + 1

# End Test 4

#--------------------------------------------------------------------------
# Test 5 - Read the data back again
#          Prove that reading a set of structures does not change it
#--------------------------------------------------------------------------
      
   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Prove non-destructive read"]

   Local_Test_Passed = FALSE

   How_Many = countof {TL_Empty_Set}

   if How_Many = 2 then
      Counter = 1

      for [A_Read_Number, A_Read_Real, A_Read_String, A_Read_Boolean] in {TL_Empty_Set} do

         if Counter = 1 and A_Read_Number  = A_First_Local_Number and \
                            A_Read_Real    = A_First_Local_Real   and \
                            A_Read_String  = A_First_Local_String and \
                            A_Read_Boolean = A_First_Local_Boolean then

            Local_Test_Passed = TRUE

         else 

            if Counter = 2 and A_Read_Number  = A_Second_Local_Number  and \
                               A_Read_Real    = A_Second_Local_Real    and \
                               A_Read_String  = A_Second_Local_String  and \
                               A_Read_Boolean = A_Second_Local_Boolean and \
                               Local_Test_Passed = TRUE then

               [] = RPT2:Test_Passed["Scenario", Test, A_Read_Number]
            else
               [] = RPT3:Test_Failed["Scenario", Test, A_Read_Number]
            endif

         endif

         Counter = Counter + 1

      endfor

   else
      [] = RPT3:Test_Failed["Scenario", Test, How_Many]
   endif

   Test = Test + 1

# End Test 5

#--------------------------------------------------------------------------
# Test 6 - Call object based synch service to create a data structure, 
#          return it and then confirm that it was created correctly.
#          This test creates a new return list for each test, so the 
#          structure is always empty when we start.
#--------------------------------------------------------------------------

   A_Real_Number = 1.0
   
   # Create a new structure object.
   {TL_Returned_Simple_Structure_1} is Type_Linked_Simple_Structure_Type

   struct_1 = create Structured_Object with Reference_SO  = Test                    &\
                                            Some_Text     = "Construct a structure" &\
                                            An_Integer    = Test                    &\
                                            A_Real        = A_Real_Number           &\
                                            A_Boolean     = TRUE                    &\
                                            A_Colour      = ''Red''                   &\
                                            Current_State = ''Idle''

   [{TL_Returned_Simple_Structure_1}] = SO5:Create_Simple_TL_Structure[Test, struct_1]

   Test = Test + 1

   [] = SO6:Decode_Simple_TL_Structure[Test, {TL_Returned_Simple_Structure_1}, struct_1, FALSE]

   delete struct_1

   Test = Test + 1

# End Test 6

#--------------------------------------------------------------------------
# Test 7 - Call object based synch service to create a data structure, 
#          return it and then confirm that it was created correctly.
#          This test uses the same return parameter for all tests, so the 
#          results are appended on to the old return structure.
#
#          This test will examine what happens when an emptied set is 
#          reused.
#          The set will be emptied by the Decode_Simple_Structure service, 
#          and then written to again by the next iteration of the 
#          Create_Simple_Structure.
#
#          It is understood that reading the final entry from a set will 
#          cause that set to be deleted. Subsequent appends to that set will
#          cause a fatal crash.
#
#          To avoid this, ensure that the final entry of a set is never read 
#          from.
#          This will prove that a set may be written to again after it has 
#          been partially read from.
#--------------------------------------------------------------------------

   Termination_Condition = Test + 10

   A_Real_Number = 1.0

   {TL_Returned_Simple_Structure_2} is Type_Linked_Simple_Structure_Type

   loop
      # Create a couple of structured objects
      struct_2 = create Structured_Object with Reference_SO  = Test                    &\
                                               Some_Text     = "Construct a structure" &\
                                               An_Integer    = Test                    &\
                                               A_Real        = A_Real_Number           &\
                                               A_Boolean     = FALSE                   &\
                                               A_Colour      = ''Red''                   &\
                                               Current_State = ''Idle''

      a_structured_instance_2 = find-one Structured_Object where Reference_SO = Test

      # Create a new structure object each time, otherwise the same
      # structure will be appended to each iteration.
      [{TL_Returned_Simple_Structure_2}] = SO5:Create_Simple_TL_Structure[Test, a_structured_instance_2]

      Test = Test + 1

      [] = SO6:Decode_Simple_TL_Structure[Test,\
                                          {TL_Returned_Simple_Structure_2},\
                                          a_structured_instance_2, \
                                          TRUE]

      # Delete the object now we''ve done with it.
      delete a_structured_instance_2

      Test = Test + 1

      breakif Test = Termination_Condition

   endloop

# End Test 7

#--------------------------------------------------------------------------
# Test 8 - Define a test which passes a single structure to an instance 
#          through a generated event.
#--------------------------------------------------------------------------

   A_Real_Number = 1.0

   struct_3 = create Structured_Object with Reference_SO  = Test                        &\
                                            Some_Text     = "generate simple structure" &\
                                            An_Integer    = Test                        &\
                                            A_Real        = A_Real_Number               &\
                                            A_Boolean     = FALSE                       &\
                                            A_Colour      = ''Red''                       &\
                                            Current_State = ''Idle''

   # Create a simple structure and pass it in to the instance Simple_F1
   {TL_Simple_Object_Structure_3} is Type_Linked_Simple_Structure_Type

   append [struct_3.Reference_SO, \
           struct_3.A_Real,       \
           struct_3.Some_Text,    \
           struct_3.A_Boolean] to {TL_Simple_Object_Structure_3}

   generate SO5:Start_TL_Simple(Test, {TL_Simple_Object_Structure_3} ) to struct_3

   Test = Test + 1

# End Test 8

#--------------------------------------------------------------------------
# Test 9 - Perform the same test again, except this time use a set of 
#          structures with more than one set in it.
#--------------------------------------------------------------------------

   A_Real_Number = 1.0

   struct_4 = create Structured_Object with Reference_SO  = Test                        &\
                                            Some_Text     = "generate simple structure" &\
                                            An_Integer    = Test                        &\
                                            A_Real        = A_Real_Number               &\
                                            A_Boolean     = FALSE                       &\
                                            A_Colour      = ''Red''                       &\
                                            Current_State = ''Idle''

   {TL_Simple_Object_Structure_4} is Type_Linked_Simple_Structure_Type

   Termination_Condition = 10
   Counter = 0

   loop
      append [struct_4.An_Integer, \
              struct_4.A_Real,     \
              struct_4.Some_Text,  \
              struct_4.A_Boolean] to {TL_Simple_Object_Structure_4}

      Counter = Counter + 1

      breakif Counter = Termination_Condition

   endloop

   generate SO5:Start_TL_Simple(Test, {TL_Simple_Object_Structure_4} ) to struct_4

   Test = Test + 1

# End Test 9

#--------------------------------------------------------------------------#
# Test 10 - Pass in the simple structure into a domain based synchronous service.
#--------------------------------------------------------------------------

   struct_5 = create Structured_Object with Reference_SO  = Test                         &\
                                            Some_Text     = "Domain based synch service" &\
                                            An_Integer    = Test                         &\
                                            A_Real        = 2.0                          &\
                                            A_Boolean     = TRUE                         &\
                                            A_Colour      = ''Red''                        &\
                                            Current_State = ''Idle''

   {TL_Simple_Object_Structure_5} is Type_Linked_Simple_Structure_Type

   Termination_Condition = 10
   Counter = 1

   loop
      append [struct_5.An_Integer, \
              struct_5.A_Real,     \
              struct_5.Some_Text,  \
              struct_5.A_Boolean] to {TL_Simple_Object_Structure_5}

      Counter = Counter + 1

      breakif Termination_Condition = Counter

   endloop

   # Invoke domain based synch. service
   [] = Struct4::Decode_Simple_TL_Structure[Test, {TL_Simple_Object_Structure_5}, struct_5]

   delete struct_5

# End Test 10

#--------------------------------------------------------------------------

Test = Test + 1

My_Test_Data.The_Test_Number = Test',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,3 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001d2","00000000-0000-0000-0000-000000000000",'Simple_Name_and_Type_Linked_Scenario',' Simple Name and Type Linked Scenario
','#--------------------------------------------------------------------------
# Setup Test Data
#
# TYPE LINKED Simple Structures
#--------------------------------------------------------------------------

My_Test_Data = find-one Test_Data

Test = My_Test_Data.The_Test_Number

#-------------------------------------------------------------------------- 
# Test 1 - Basic ''APPEND'' operation tests
#          This test shall prove that a set is created empty.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Create empty NTL structure"]

   {NTL_Empty_Set} is Name_and_Type_Linked_Simple_Structure_Type

   Naught = countof {NTL_Empty_Set}

   if Naught = 0 then 
      [] = RPT2:Test_Passed["Scenario", Test, 0]
   else
      [] = RPT3:Test_Failed["Scenario", Test, Naught]
   endif

   Test = Test + 1

# End Test 1

#--------------------------------------------------------------------------
# Test 2 - Add some data into the set.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Add first NTL structure to set"]

   A_First_Local_Number  = 100
   A_First_Local_Real    = 100.0
   A_First_Local_String  = "Hello Good Evening and Welcome"
   A_First_Local_Boolean = TRUE

   append [A_First_Local_Number, A_First_Local_Real, A_First_Local_String, A_First_Local_Boolean] to {NTL_Empty_Set}

   One = countof {NTL_Empty_Set}

   if One = 1 then
      [] = RPT2:Test_Passed["Scenario", Test, One]
   else
      [] = RPT3:Test_Failed["Scenario", Test, One]
   endif

   Test = Test + 1

# End Test 2

#--------------------------------------------------------------------------
# Test 3 - Add some more data into the set.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Add second NTL structure to set"]

   A_Second_Local_Number  = 200
   A_Second_Local_Real    = 200.0
   A_Second_Local_String  = "Thankyou and Goodnight"
   A_Second_Local_Boolean = FALSE

   append [A_Second_Local_Number, A_Second_Local_Real, A_Second_Local_String, A_Second_Local_Boolean] to {NTL_Empty_Set}

   Two = countof {NTL_Empty_Set}

   if Two = 2 then
      [] = RPT2:Test_Passed["Scenario", Test, Two]
   else
      [] = RPT3:Test_Failed["Scenario", Test, Two]
   endif

   Test = Test + 1

# End Test 3

#--------------------------------------------------------------------------
# Test 4 - Read the data back
#          The Queue is implemented as a FIFO, so read it back as such.
#          This test will need to change should this implementation ever
#          change. This test will fail if this happens.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Read back TL structure from set"]

   Counter = 1
   Local_Test_Passed = FALSE

   for [A_Read_Number, A_Read_Real, A_Read_String, A_Read_Boolean] in {NTL_Empty_Set} do

      if Counter = 1 and A_Read_Number  = A_First_Local_Number  and \
                         A_Read_Real    = A_First_Local_Real    and \
                         A_Read_String  = A_First_Local_String  and \
                         A_Read_Boolean = A_First_Local_Boolean then

         Local_Test_Passed = TRUE
      else

         if Counter = 2 and A_Read_Number  = A_Second_Local_Number  and \
                            A_Read_Real    = A_Second_Local_Real    and \
                            A_Read_String  = A_Second_Local_String  and \
                            A_Read_Boolean = A_Second_Local_Boolean and \
                            Local_Test_Passed = TRUE then

            [] = RPT2:Test_Passed["Scenario", Test, A_Read_Number]
         else
            [] = RPT3:Test_Failed["Scenario", Test, A_Read_Number]
         endif

      endif

      Counter = Counter + 1

   endfor

   Test = Test + 1

# End Test 4

#--------------------------------------------------------------------------
# Test 5 - Read the data back again
#          Prove that reading a set of structures does not change it
#--------------------------------------------------------------------------
      
   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Scenario", "Prove non-destructive read"]

   Local_Test_Passed = FALSE

   How_Many = countof {NTL_Empty_Set}

   if How_Many = 2 then
      Counter = 1

      for [A_Read_Number, A_Read_Real, A_Read_String, A_Read_Boolean] in {NTL_Empty_Set} do

         if Counter = 1 and A_Read_Number  = A_First_Local_Number and \
                            A_Read_Real    = A_First_Local_Real   and \
                            A_Read_String  = A_First_Local_String and \
                            A_Read_Boolean = A_First_Local_Boolean then

            Local_Test_Passed = TRUE
         else 

            if Counter = 2 and A_Read_Number  = A_Second_Local_Number  and \
                               A_Read_Real    = A_Second_Local_Real    and \
                               A_Read_String  = A_Second_Local_String  and \
                               A_Read_Boolean = A_Second_Local_Boolean and \
                               Local_Test_Passed = TRUE then

               [] = RPT2:Test_Passed["Scenario", Test, A_Read_Number]
            else
               [] = RPT3:Test_Failed["Scenario", Test, A_Read_Number]
            endif

         endif

         Counter = Counter + 1

      endfor

   else
      [] = RPT3:Test_Failed["Scenario", Test, How_Many]
   endif

   Test = Test + 1

# End Test 5

#--------------------------------------------------------------------------
# Test 6 - Call object based synch service to create a data structure, 
#          return it and then confirm that it was created correctly.
#          This test creates a new return list for each test, so the 
#          structure is always empty when we start.
#--------------------------------------------------------------------------

   A_Real_Number = 1.0
   
   # Create a new structure object.
   {NTL_Returned_Simple_Structure_1} is Name_and_Type_Linked_Simple_Structure_Type

   struct_1 = create Structured_Object with Reference_SO  = Test                    &\
                                            Some_Text     = "Construct a structure" &\
                                            An_Integer    = Test                    &\
                                            A_Real        = A_Real_Number           &\
                                            A_Boolean     = TRUE                    &\
                                            A_Colour      = ''Blue''                  &\
                                            Current_State = ''Idle''

   [{NTL_Returned_Simple_Structure_1}] = SO7:Create_Simple_NTL_Structure[Test, struct_1]

   Test = Test + 1

   [] = SO8:Decode_Simple_NTL_Structure[Test, {NTL_Returned_Simple_Structure_1}, struct_1, FALSE]

   delete struct_1

   Test = Test + 1

# End Test 6

#--------------------------------------------------------------------------
# Test 7 - Call object based synch service to create a data structure, 
#          return it and then confirm that it was created correctly.
#          This test uses the same return parameter for all tests, so the 
#          results are appended on to the old return structure.
#
#          This test will examine what happens when an emptied set is 
#          reused.
#          The set will be emptied by the Decode_Simple_Structure service, 
#          and then written to again by the next iteration of the 
#          Create_Simple_Structure.
#
#          It is understood that reading the final entry from a set will 
#          cause that set to be deleted. Subsequent appends to that set will 
#          cause a fatal crash.
#
#          To avoid this, ensure that the final entry of a set is never read
#          from.
#          This will prove that a set may be written to again after it has 
#          been partially read from.
#--------------------------------------------------------------------------

   Termination_Condition = Test + 10

   A_Real_Number = 1.0

   {NTL_Returned_Simple_Structure_2} is Name_and_Type_Linked_Simple_Structure_Type

   loop

      # Create a couple of structured objects
      struct_2 = create Structured_Object with Reference_SO  = Test                    &\
                                               Some_Text     = "Construct a structure" &\
                                               An_Integer    = Test                    &\
                                               A_Real        = A_Real_Number           &\
                                               A_Boolean     = FALSE                   &\
                                               A_Colour      = ''Blue''                  &\
                                               Current_State = ''Idle''

      a_structured_instance_2 = find-one Structured_Object where Reference_SO = Test

      # Create a new structure object each time, otherwise the same
      # structure will be appended to each iteration.

      [{NTL_Returned_Simple_Structure_2}] = SO7:Create_Simple_NTL_Structure[Test, a_structured_instance_2]

      Test = Test + 1
  
      [] = SO8:Decode_Simple_NTL_Structure[Test, \
                                           {NTL_Returned_Simple_Structure_2},\
                                           a_structured_instance_2, \
                                           TRUE]

      # Delete the object now we''ve done with it.
      delete a_structured_instance_2

      Test = Test + 1

      breakif Test = Termination_Condition

   endloop

# End Test 7

#--------------------------------------------------------------------------
# Test 8 - Define a test which passes a single structure to an instance 
#          through a generated event.
#--------------------------------------------------------------------------

   A_Real_Number = 1.0

   struct_3 = create Structured_Object with Reference_SO  = Test                        &\
                                            Some_Text     = "generate simple structure" &\
                                            An_Integer    = Test                        &\
                                            A_Real        = A_Real_Number               &\
                                            A_Boolean     = FALSE                       &\
                                            A_Colour      = ''Blue''                      &\
                                            Current_State = ''Idle''

   # Create a simple structure and pass it in to the instance Simple_F1
   {NTL_Simple_Object_Structure_3} is Name_and_Type_Linked_Simple_Structure_Type

   append [struct_3.Reference_SO, \
           struct_3.A_Real,       \
           struct_3.Some_Text,    \ 
           struct_3.A_Boolean] to {NTL_Simple_Object_Structure_3}

   generate SO6:Start_NTL_Simple(Test, {NTL_Simple_Object_Structure_3} ) to struct_3

   Test = Test + 1

# End Test 8

#--------------------------------------------------------------------------
# Test 9 - Perform the same test again, except this time use a set of 
#          structures with more than one set in it.
#--------------------------------------------------------------------------

   A_Real_Number = 1.0

   struct_4 = create Structured_Object with Reference_SO  = Test                        &\
                                            Some_Text     = "generate simple structure" &\
                                            An_Integer    = Test                        &\
                                            A_Real        = A_Real_Number               &\
                                            A_Boolean     = FALSE                       &\
                                            A_Colour      = ''Blue''                      &\ 
                                            Current_State = ''Idle''

   {NTL_Simple_Object_Structure_4} is Name_and_Type_Linked_Simple_Structure_Type

   Termination_Condition = 10
   Counter = 0

   loop
      append [struct_4.An_Integer, \
              struct_4.A_Real,     \
              struct_4.Some_Text,   \
              struct_4.A_Boolean] to {NTL_Simple_Object_Structure_4}

      Counter = Counter + 1

      breakif Counter = Termination_Condition

   endloop

   generate SO6:Start_NTL_Simple(Test, {NTL_Simple_Object_Structure_4} ) to struct_4

   Test = Test + 1

# End Test 9

#--------------------------------------------------------------------------
# Test 10 - Pass in the simple structure into a domain based synchronous 
#           service.
#--------------------------------------------------------------------------

   struct_5 = create Structured_Object with Reference_SO  = Test                         &\
                                            Some_Text     = "Domain based synch service" &\
                                            An_Integer    = Test                         &\
                                            A_Real        = 2.0                          &\
                                            A_Boolean     = TRUE                         &\
                                            A_Colour      = ''Blue''                       &\
                                            Current_State = ''Idle''

   {NTL_Simple_Object_Structure_5} is Name_and_Type_Linked_Simple_Structure_Type

   Termination_Condition = 10
   Counter = 1

   loop
      append [struct_5.An_Integer, \
              struct_5.A_Real,     \
              struct_5.Some_Text,  \
              struct_5.A_Boolean] to {NTL_Simple_Object_Structure_5}

      Counter = Counter + 1

      breakif Termination_Condition = Counter

   endloop

   # Invoke domain based synch. service
   [] = Struct6::Decode_Simple_NTL_Structure[Test,\
                                            {NTL_Simple_Object_Structure_5},           \
                                            struct_5] 

   delete struct_5

# End Test 10

#--------------------------------------------------------------------------

Test = Test + 1

My_Test_Data.The_Test_Number = Test',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,4 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001d4","00000000-0000-0000-0000-000000000000",'Nested_Structure_Scenario',' Nested Structure Scenario
','My_Test_Data = find-one Test_Data

local_test_number = My_Test_Data.The_Test_Number


#--------------------------------------------------------------------------
# Test 1 - Create a nested stucture containing another structure which in 
#          turn contains another structure. Pass it into a domain based 
#          synchronous service for decoding.
#--------------------------------------------------------------------------

   Zero  = 0
   One   = 1
   Two   = 2
   Three = 3

   The_Colour of Colour_Type = ''Blue''

   {The_Third_Structure}  is Third_Nested_Structure_Type
   {The_Second_Structure} is Second_Nested_Structure_Type
   {The_First_Structure}  is First_Nested_Structure_Type

   append [Three, The_Colour]           to {The_Third_Structure}
   append [{The_Third_Structure}, Two]  to {The_Second_Structure}
   append [{The_Second_Structure}, One] to {The_First_Structure}

   [] = Struct7::Decode_Three_Level_Nested_Structure [local_test_number,     \
                                                      {The_First_Structure}, \
                                                      {The_Second_Structure},\
                                                      {The_Third_Structure}, \
                                                      One, One,              \
                                                      Two, One,              \
                                                      Three, One, The_Colour]

   local_test_number = local_test_number + 1

# End Test 1

#--------------------------------------------------------------------------
# Test 2 
#--------------------------------------------------------------------------

   {The_Next_First_Structure}  is First_Nested_Structure_Type
   {The_Next_Second_Structure} is Second_Nested_Structure_Type
   {The_Next_Third_Structure}  is Third_Nested_Structure_Type

   termination_condition = Three

   loop
      append [Three, The_Colour] to {The_Next_Third_Structure}
      termination_condition = termination_condition - 1
      breakif termination_condition = Zero
   endloop

   termination_condition = Three

   loop
      append [{The_Next_Third_Structure}, Two] to {The_Next_Second_Structure}
      termination_condition = termination_condition - 1
      breakif termination_condition = Zero
   endloop

   termination_condition = Three

   loop
      append [ {The_Next_Second_Structure}, One] to {The_Next_First_Structure}
      termination_condition = termination_condition - 1
      breakif termination_condition = Zero
   endloop

   [] = Struct7::Decode_Three_Level_Nested_Structure [local_test_number,          \
                                                      {The_Next_First_Structure}, \
                                                      {The_Next_Second_Structure},\
                                                      {The_Next_Third_Structure}, \
                                                      One, Three,                 \
                                                      Two, Three,                 \
                                                      Three, Three, The_Colour]

   local_test_number = local_test_number + 1

# End Test 2

#--------------------------------------------------------------------------
# Test 3 - create a Beasty test. This is where a primitve component of the
#          structure is defined, and the sub (nested) structure component 
#          is null.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[local_test_number,"1241-0000-01-1212", "Structures", "Complex nested structures", "contains a null structure"]

   {This_First_Structure} is First_Nested_Structure_Type
   {This_Second_Structure} is Second_Nested_Structure_Type

   append [ {This_Second_Structure} , One] to {This_First_Structure}

   how_many = countof {This_First_Structure} 

   if how_many = 1 then
      [] = RPT2:Test_Passed["null structure", local_test_number, 0]
   else
      [] = RPT3:Test_Failed["null_structure", local_test_number, how_many]
   endif

   local_test_number = local_test_number + 1

# End Test 3

#--------------------------------------------------------------------------

My_Test_Data.The_Test_Number = local_test_number
',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,5 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001d6","00000000-0000-0000-0000-000000000000",'Start_Structures_Tests',' Start_Structures_Tests
','My_Test_Data = create Test_Data with The_Test_Number = 1
[] = Struct8::Create_Report_Data[]',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,6 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001d8","00000000-0000-0000-0000-000000000000",'Finish_Structures_Tests',' Finish_Structures_Tests
','[] = Struct9::Delete_Report_Data[]

my_test_data = find-one Test_Data

if my_test_data != UNDEFINED then

   delete my_test_data

endif
',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,7 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001da","00000000-0000-0000-0000-000000000000",'Multiple_Structures_In_A_Structure_Scenario',' Multiple_Structures_In_A_Structure_Scenario
','#--------------------------------------------------------------------------
# This scenario contains tests that are unsupported by WACA at version 3.0.1
# Introduced for version 4.0.0 and onwards.
#--------------------------------------------------------------------------

my_test = find-one Test_Data
Test    = my_test.The_Test_Number
Zero     = 0

#--------------------------------------------------------------------------
# Test 1 - 
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Multiple Structures Scenario", "Two populated structures in one"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0121"]

   # Append populated simple structures to a multiple structure.
   {Two_Structures}               is Two_Structures_Type
   {Two_Simple_Structure}         is Simple_Structure_Type
   {Two_Another_Simple_Structure} is Third_Nested_Structure_Type

   this_int     = 100
   this_real    = 200.0
   this_text    = "Bag of bytes"
   this_boolean = TRUE

   this_colour of Colour_Type = ''Blue''

   append [this_int, this_real, this_text, this_boolean, this_colour] to {Two_Simple_Structure}
   append [this_int, this_colour]                                     to {Two_Another_Simple_Structure}
   append [{Two_Simple_Structure}, {Two_Another_Simple_Structure}]    to {Two_Structures}

   Number_In_Two_Structures   = countof {Two_Structures}
   Number_In_First_Structure  = countof {Two_Simple_Structure}
   Number_In_Second_Structure = countof {Two_Another_Simple_Structure}

   if Number_In_Two_Structures   = 1      &\
      Number_In_First_Structure  = 1      &\
      Number_In_Second_Structure = 1 then

      [] = RPT2:Test_Passed["Two populated sets in 1 structure", Test, Number_In_Two_Structures]
   else
      [] = RPT3:Test_Failed["Two populated sets in 1 structure", Test, Number_In_Two_Structures]
   endif

   Test = Test + 1

# End Test 1

#--------------------------------------------------------------------------
# Test 2
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Multiple Structures Scenario", "Another two populated structures in one"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0121"]

   # Append populated simple structures to a multiple structure.
   append [this_int, this_real, this_text, this_boolean, this_colour] to {Two_Simple_Structure}
   append [this_int, this_colour]                                     to {Two_Another_Simple_Structure}
   append [{Two_Simple_Structure}, {Two_Another_Simple_Structure}]    to {Two_Structures}

   Number_In_Two_Structures   = countof {Two_Structures}
   Number_In_First_Structure  = countof {Two_Simple_Structure}
   Number_In_Second_Structure = countof {Two_Another_Simple_Structure}


   if Number_In_Two_Structures = 2 & Number_In_First_Structure = 2 & Number_In_Second_Structure = 2 then
      [] = RPT2:Test_Passed["Another two populated sets in 1 structure", Test, Number_In_Two_Structures]
   else
      [] = RPT3:Test_Failed["Another two populated sets in 1 structure", Test, Number_In_Two_Structures]
   endif

   Test = Test + 1

# End Test 2

#--------------------------------------------------------------------------
# Test 3
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Multiple Structures Scenario", "Third two populated structures in one"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0121"]

   # Append populated simple structures to a multiple structure.
   append [this_int, this_real, this_text, this_boolean, this_colour] to {Two_Simple_Structure}
   append [this_int, this_colour]                                     to {Two_Another_Simple_Structure}
   append [{Two_Simple_Structure}, {Two_Another_Simple_Structure}]    to {Two_Structures}

   Number_In_Two_Structures   = countof {Two_Structures}
   Number_In_First_Structure  = countof {Two_Simple_Structure}
   Number_In_Second_Structure = countof {Two_Another_Simple_Structure}

   if Number_In_Two_Structures   = 3 &\
      Number_In_First_Structure  = 3  &\
      Number_In_Second_Structure = 3 then

      [] = RPT2:Test_Passed["Third two populated sets in 1 structure", Test, Number_In_Two_Structures]
   else
      [] = RPT3:Test_Failed["Third two populated sets in 1 structure", Test, Number_In_Two_Structures]
   endif

   Test = Test + 1

# End Test 3

#--------------------------------------------------------------------------
# Test 4 - Decode appended populated simple structures from multiple structure.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Multiple Structures Scenario", "Decode Two structures in one"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0121"]

   Final_Result                 = 0
   First_Countof                = 0
   Second_Countof               = 0
   How_Many_In_First_Structure  = 0
   How_Many_In_Second_Structure = 0

   for [{Decode_First}, {Decode_Second}] in {Two_Structures} do
      How_Many_In_First_Structure  = countof {Decode_First}
      How_Many_In_Second_Structure = countof {Decode_Second}

      First_Countof  = First_Countof  + How_Many_In_First_Structure
      Second_Countof = Second_Countof + How_Many_In_Second_Structure
   endfor

   Number_In_Overall_Structure   = countof {Two_Structures}

   Final_Result = First_Countof + Second_Countof + Number_In_Overall_Structure

   if First_Countof = 6 & Second_Countof = 6 & Number_In_Overall_Structure = 3 then
      [] = RPT2:Test_Passed["Decode Two structures in one", Test, Final_Result]
   else
      [] = RPT3:Test_Failed["Decode Two structures in one", Test, Final_Result]
   endif

   Test = Test + 1

# End Test 4

#--------------------------------------------------------------------------
# Test 5 - Complex multiple structure
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Multiple Structures Scenario", "Multiple populated sets in 2nd structure"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0121"]

   an_integer = 1

   alternative_colour of Alternative_Colour_Type = ''Red''
   normal_colour of Colour_Type = ''Red''

   {multiple_structure}       is Multiple_Structures_Type
   {local_first_structure}    is First_Nested_Structure_Type
   {local_second_structure}   is Second_Nested_Structure_Type
   {local_third_structure}    is Third_Nested_Structure_Type
   {different_colours}        is Different_Structure_Type

   append [alternative_colour, Zero]                                                                 to {different_colours}
   append [an_integer, normal_colour]                                                                to {local_third_structure}
   append [{local_third_structure}, an_integer]                                                      to {local_second_structure}
   append [{local_second_structure}, an_integer]                                                     to {local_first_structure}
   append [ {local_first_structure}, {local_second_structure}, {local_third_structure}, an_integer ] to {multiple_structure}


   Number_In_Multiple_Structure = countof {multiple_structure}
   Number_In_First_Structure    = countof {local_first_structure}
   Number_In_Second_Structure   = countof {local_second_structure}
   Number_In_Third_Structure    = countof {local_third_structure}


   if Number_In_Multiple_Structure = 1 &\
      Number_In_First_Structure    = 1 &\
      Number_In_Third_Structure    = 1 &\
      Number_In_Second_Structure   = 1 then
 
      [] = RPT2:Test_Passed["Multiple populated sets in 2nd structure", Test, Number_In_Multiple_Structure]

   else
      [] = RPT3:Test_Failed["Multiple populated sets in 2nd structure", Test, Number_In_Multiple_Structure]
      [] = RPT5:Test_Text[Number_In_First_Structure, "First"]
      [] = RPT5:Test_Text[Number_In_Second_Structure, "Second"]
      [] = RPT5:Test_Text[Number_In_Third_Structure, "Third"]
   endif

   Test = Test + 1

# End Test 5

#--------------------------------------------------------------------------
# Test 6 - Complex multiple structure
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Multiple Structures Scenario", "2nd Multiple populated sets in 2nd structure"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0121"]

   an_integer = 2

   append [alternative_colour, Zero]             to {different_colours}
   append [an_integer, normal_colour]            to {local_third_structure}
   append [{local_third_structure}, an_integer]  to {local_second_structure}
   append [{local_second_structure}, an_integer] to {local_first_structure}

   append [ {local_first_structure}, {local_second_structure}, {local_third_structure}, an_integer ] to {multiple_structure}

   Number_In_Multiple_Structure = countof {multiple_structure}
   Number_In_First_Structure    = countof {local_first_structure}
   Number_In_Second_Structure   = countof {local_second_structure}
   Number_In_Third_Structure    = countof {local_third_structure}

   if Number_In_Multiple_Structure = 2 &\ 
      Number_In_First_Structure    = 2 &\
      Number_In_Third_Structure    = 2 &\
      Number_In_Second_Structure   = 2 then
 
      [] = RPT2:Test_Passed["2nd Multiple populated sets in 2nd structure", Test, Number_In_Multiple_Structure]
   else
      [] = RPT3:Test_Failed["2nd Multiple populated sets in 2nd structure", Test, Number_In_Multiple_Structure]
      [] = RPT5:Test_Text[Number_In_First_Structure, "First"]
      [] = RPT5:Test_Text[Number_In_Second_Structure, "Second"]
      [] = RPT5:Test_Text[Number_In_Third_Structure, "Third"]
   endif

   Test = Test + 1

# End Test 6

#--------------------------------------------------------------------------
# Test 7 - Complex multiple structure
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Multiple Structures Scenario", "3rd Multiple populated sets in 2nd structure"]
   [] = RPT8:Specify_Requid[Test, "1101-0000-01-0121"]

   an_integer = 3

   append [alternative_colour, Zero]             to {different_colours}
   append [an_integer, normal_colour]            to {local_third_structure}
   append [{local_third_structure}, an_integer]  to {local_second_structure}
   append [{local_second_structure}, an_integer] to {local_first_structure}

   append [ {local_first_structure}, {local_second_structure}, {local_third_structure}, an_integer ] to {multiple_structure}


   Number_In_Multiple_Structure = countof {multiple_structure}
   Number_In_First_Structure    = countof {local_first_structure}
   Number_In_Second_Structure   = countof {local_second_structure}
   Number_In_Third_Structure    = countof {local_third_structure}

   if Number_In_Multiple_Structure = 3 &\
      Number_In_First_Structure    = 3 &\
      Number_In_Third_Structure    = 3 &\
      Number_In_Second_Structure   = 3 then
 
      [] = RPT2:Test_Passed["3rd Multiple populated sets in 2nd structure", Test, Number_In_Multiple_Structure]
   else
      [] = RPT3:Test_Failed["3rd Multiple populated sets in 2nd structure", Test, Number_In_Multiple_Structure]

      [] = RPT5:Test_Text[Number_In_First_Structure, "First"]
      [] = RPT5:Test_Text[Number_In_Second_Structure, "Second"]
      [] = RPT5:Test_Text[Number_In_Third_Structure, "Third"]
   endif

   Test = Test + 1

# End Test 7

#--------------------------------------------------------------------------

my_test.The_Test_Number = Test',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,8 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001dc","00000000-0000-0000-0000-000000000000",'Empty_Structures_Test',' Empty_Structures_Test
','my_test = find-one Test_Data

Test = my_test.The_Test_Number

[Environment] = ET1:Env_String[]

#--------------------------------------------------------------------------
# Test 1 
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Empty Sets Scenario", "Append one empty structures in one"]

   # Append one empty simple structure to a parent structure.
   {Parent_Structure} is Complex_UDT_Structure_Type
   {Child_Structure} is UDT_Structure_Type

   one   = 1
   two   = 2.0
   three = 3

   This_Blue of Colour_Type = ''Blue''

   append [ one, two,  {Child_Structure}, three, This_Blue ] to {Parent_Structure}
   
   Number_In_Child_Structure   = countof {Child_Structure}
   Number_In_Parent_Structure  = countof {Parent_Structure}

   if Number_In_Parent_Structure = 1 & Number_In_Child_Structure  = 0 then
      [] = RPT2:Test_Passed["One empty sets in 1 structure", Test, Number_In_Parent_Structure]
   else
      [] = RPT3:Test_Failed["One empty sets in 1 structure", Test, Number_In_Parent_Structure]
   endif

   Test = Test + 1

# End Test 1

#--------------------------------------------------------------------------
# Test 2
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Empty Sets Scenario", "Two empty structures in one"]

   # Append two empty simple structures to a multiple structure.
   {Two_Structures}               is Two_Structures_Type
   {Two_Simple_Structure}         is Simple_Structure_Type
   {Two_Another_Simple_Structure} is Third_Nested_Structure_Type
   
   append [{Two_Simple_Structure}, {Two_Another_Simple_Structure}] to {Two_Structures}

   Number_In_Two_Structures   = countof {Two_Structures}
   Number_In_First_Structure  = countof {Two_Simple_Structure}
   Number_In_Second_Structure = countof {Two_Another_Simple_Structure}

   if Number_In_Two_Structures   = 1 &\
      Number_In_First_Structure  = 0 &\
      Number_In_Second_Structure = 0 then

      [] = RPT2:Test_Passed["Two empty sets in 1 structure", Test, Number_In_Two_Structures]
   else
      [] = RPT3:Test_Failed["Two empty sets in 1 structure", Test, Number_In_Two_Structures]
   endif

   Test = Test + 1

# End Test 2

#--------------------------------------------------------------------------
# Test 3 - Complex multiple structure
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Empty Sets Scenario", "Multiple empty sets in 1 structure"]

   {multiple_structure}     is Multiple_Structures_Type
   {local_first_structure}  is First_Nested_Structure_Type
   {local_second_structure} is Second_Nested_Structure_Type
   {local_third_structure}  is Third_Nested_Structure_Type
   {different_colours}      is Different_Structure_Type

   append [ {local_first_structure}, {local_second_structure}, {local_third_structure} ] to {multiple_structure}

   Number_in_Multiple_Structure = countof {multiple_structure}

   if Number_in_Multiple_Structure = 1 then
      [] = RPT2:Test_Passed["Multiple empty sets in 1 structure", Test, Number_in_Multiple_Structure]
   else
      [] = RPT3:Test_Failed["Multiple empty sets in 1 structure", Test, Number_in_Multiple_Structure]
   endif

   Test = Test + 1

# End Test 3

#--------------------------------------------------------------------------

my_test.The_Test_Number = Test',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,9 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001de","00000000-0000-0000-0000-000000000000",'Test_IH_In_Structures',' Test_IH_In_Structures
','my_test = find-one Test_Data

[Environment] = ET1:Env_String[]

Test_Number = my_test.The_Test_Number

#--------------------------------------------------------------------------
# Test 1 - First test in the sequence.
#          Create a Structured Object and append it to a structure.
#--------------------------------------------------------------------------

   Primary_SO = create unique Structured_Object with An_Integer    = Test_Number &\
                                                     A_Real        = 1.0         &\
                                                     Some_Text     = "No text"   &\
                                                     A_Boolean     = TRUE        &\
                                                     A_Colour      = ''Red''       &\
                                                     Current_State = ''Idle''

   # Take a copy of the preferred attribute for later use.
   Local_Copy_Of_IH_Identifer = Primary_SO.Reference_SO

   {The_First_Structure} is Structure_and_IH_Type

   append [Primary_SO] to {The_First_Structure}

   [] = Struct1::Receive_Structure_IH [Test_Number, {The_First_Structure}, 1, \
                                       Primary_SO.Reference_SO, "Single instance in structure"]

   Test_Number = Test_Number + 1

# End Test 1

#--------------------------------------------------------------------------
# Test 2 - Do the same test again, on the same data to prove that it has 
#          not been corrupted and/or modified. Use the previously stored 
#          value to compare against.
#--------------------------------------------------------------------------

   [] = Struct1::Receive_Structure_IH [Test_Number, {The_First_Structure}, 1, \
                                       Local_Copy_Of_IH_Identifer, "Second bite at Single instance in structure"]

   Test_Number = Test_Number + 1

# End Test 2

#--------------------------------------------------------------------------
# Test 3 - Create a second Structured Object and append it to a structure.
#--------------------------------------------------------------------------

   Secondary_SO = create unique Structured_Object with An_Integer    = Test_Number &\
                                                       A_Real        = 2.0         &\
                                                       Some_Text     = "No text"   &\
                                                       A_Boolean     = TRUE        &\
                                                       A_Colour      = ''Red''       &\
                                                       Current_State = ''Idle''

   # Take a copy of the preferred attribute for later use.
   Local_Copy_Of_IH_Identifer = Secondary_SO.Reference_SO

   append [Secondary_SO] to {The_First_Structure}

   [] = Struct1::Receive_Structure_IH [Test_Number, {The_First_Structure}, 2, \
                                       Secondary_SO.Reference_SO, "Second instance in structure"]

   Test_Number = Test_Number + 1

# End Test 3

#--------------------------------------------------------------------------
# Test 4 - Do the same test again, on the same data to prove that it has 
#          not been corrupted and/or modified. Use the previously stored 
#          value to compare against.
#--------------------------------------------------------------------------

   [] = Struct1::Receive_Structure_IH [Test_Number, {The_First_Structure}, 2, \
                                       Local_Copy_Of_IH_Identifer, "Second bite at Second instance in structure"]

# End Test 4

#--------------------------------------------------------------------------
# Test 5 - Send an empty structure to the target function. This may be 
#          required as a target function could return a non-empty structure
#--------------------------------------------------------------------------

#Test_Number = Test_Number + 1

# UNSUPPORTED 


# Clear up, but delete {The_First_Structure} operation is not implemented in ASL.
# So, create a new structure over the old one.

# This test ensures that redeclaring the structure clears it out completely.

# {The_First_Structure} is Structure_and_IH_Type

# {Returned_Structure}  is Structure_and_IH_Type

# [{Returned_Structure}] = Struct3::Receive_Empty_Structure_IH [Test_Number, {The_First_Structure}, \
#    Primary_SO, "Pass in empty structure, return full"]

#--------------------------------------------------------------------------

# Using the return from the previous test, check to see that the return parameter has been
# created and silled out as expected.

# UNSUPPORTED due to previous test

#Test_Number = Test_Number + 1

#[] = Struct1::Receive_Structure_IH [Test_Number, {Returned_Structure}, 1, \
#   Primary_SO.Reference_SO, "Previously returned structure is ok"]



#--------------------------------------------------------------------------
# Series of tests
#--------------------------------------------------------------------------

   bean_counter = 1

   {Next_Structure} is Structure_and_IH_Type

   loop
      Test_Number = Test_Number + 1

      Next_SO = create unique Structured_Object with An_Integer    = Test_Number &\
                                                     A_Real        = 1.0         &\
                                                     Some_Text     = "No text"   &\
                                                     A_Boolean     = TRUE        &\
                                                     A_Colour      = ''Red''       &\
                                                     Current_State = ''Idle''

      append [Next_SO] to {Next_Structure}

      [] = Struct1::Receive_Structure_IH [Test_Number, {Next_Structure}, bean_counter, Next_SO.Reference_SO, "Many instances in structure"]
 
      bean_counter = bean_counter + 1

      breakif bean_counter > 5

   endloop

#--------------------------------------------------------------------------
# Next series of tests. Let''s see what happens when the structure is deleted after it is appended.
# This test will make sure that the data is copied into the target structure, and not just passed
# by reference.
#--------------------------------------------------------------------------

   bean_counter = 1

   {Delete_Structure} is Structure_and_IH_Type

   loop
      Test_Number = Test_Number + 1

      # Resuse the Next_SO data name.
      Next_SO = create unique Structured_Object with An_Integer    = Test_Number &\
                                                     A_Real        = 1.0         &\
                                                     Some_Text     = "No text"   &\
                                                     A_Boolean     = TRUE        &\
                                                     A_Colour      = ''Red''       &\
                                                     Current_State = ''Idle''

      SO_ID = Next_SO.Reference_SO

      append [Next_SO] to {Delete_Structure}

      [] = Struct1::Receive_Structure_IH [Test_Number, {Delete_Structure}, bean_counter, SO_ID, "Structure fully copied"]

      # Deleting the instance object before it is passed into the function call as a component of the structure
      # causes I-Sim grief. It appears that a shallow copy is taken, ie. it is passed by reference. To prove this
      # delete the instance object and then do the same test again.
      if Environment = "WACA" then
         delete Next_SO
      endif

      Test_Number = Test_Number + 1

      [] = Struct1::Receive_Structure_IH [Test_Number, {Delete_Structure}, bean_counter, SO_ID, "Structure fully copied"]
 
      bean_counter = bean_counter + 1

      breakif bean_counter > 5

   endloop

   # Delete structure is not supported by ASL or WACA, although it will compile.
   # Run_Time crash in I-SIM awaits the unwary.
   # delete {Next_Structure}


#--------------------------------------------------------------------------
# Tidy up and finish this sequence of tests.
#--------------------------------------------------------------------------

Test_Number = Test_Number + 1

my_test.The_Test_Number = Test_Number',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,10 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001e0","00000000-0000-0000-0000-000000000000",'Structures_are_Cleared',' Structures_are_Cleared
','#--------------------------------------------------------------------------
# These series of tests ensure that although there is no way of deleting a 
# structure once it is in existance, we can at least reduce the structure 
# back to being empty when necessary.
#--------------------------------------------------------------------------

my_test = find-one Test_Data

Test_Number = my_test.The_Test_Number

#--------------------------------------------------------------------------
# Test 1 - Create a Structure and append to it.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test_Number, "1241-0000-01-1212", "Structures", "Structures cleared", "Structures memory usage test"]

   {Simple_Destructive_Structure} is Simple_Structure_Type

   # Blunder round a loop ten thousand times, adding fifty structures into 
   # the set of structure. This should give an indication of whether WACA 
   # returns the freed space back to the heap after the structure is 
   # redeclared.

   # NB. Use the Performance Meter in the Windows NT task manager
   #     to monitor memory usage.

   Number_Of_Iterations = 10000
   Number_Of_Appends = 50

   # Test data section
   The_Integer = Test_Number
   The_Real    = 0.99
   The_Text    = "How big?"
   The_Boolean = FALSE

   The_Colour of Colour_Type = ''Blue''

   Little_Bean_Counter = 0
   Big_Bean_Counter    = 0

   Test_Has_Failed = FALSE

   loop
      Little_Bean_Counter = 0

      loop
         append [The_Integer, The_Real, The_Text, The_Boolean, The_Colour] to {Simple_Destructive_Structure}

         breakif Little_Bean_Counter = Number_Of_Appends
  
         Little_Bean_Counter = Little_Bean_Counter + 1
      endloop

      # Redeclare the structure, effectively removing the fully defined
      # structure and resetting it to zero size.
      {Simple_Destructive_Structure} is Simple_Structure_Type

      # If the structure has not been cleaned up, bail out. There is
      # no point continuing.

      How_Many_Now = countof {Simple_Destructive_Structure}
      if How_Many_Now != 0 then
         Test_Has_Failed = TRUE
         break
      endif

      breakif Big_Bean_Counter = Number_Of_Iterations

      Big_Bean_Counter = Big_Bean_Counter + 1

   endloop

   if Test_Has_Failed then
      [] = RPT3:Test_Failed["Structures not cleared up", Test_Number, Big_Bean_Counter]
   else
      Result_Value = Little_Bean_Counter * Big_Bean_Counter
      [] = RPT2:Test_Passed["Structures cleared", Test_Number, Result_Value]
   endif

   Test_Number = Test_Number + 1

# End Test 1

#--------------------------------------------------------------------------
# Test 2
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test_Number, "1241-0000-01-1212", "Structures", "Structures cleared", "Reuse Structure name with different type"]

   Little_Bean_Counter = 0
   Big_Bean_Counter    = 1

   {Simple_Destructive_Structure} is Simple_Structure_Type

   # Blunder round a loop two times, adding two hundred and fifty thousand
   # structures into the set of structure. This should give an indication of 
   # whether WACA returns the freed space back to the heap after the structure 
   # is redeclared.

   # NB. Use the Performance Meter in the Windows NT task manager
   #     to monitor memory usage.

   Number_Of_Iterations = 2
   Number_Of_Appends = 250000

   # Test data section
   The_Integer = Test_Number
   The_Real    = 0.99
   The_Text    = "Different structure type"
   The_Boolean = FALSE

   The_Colour of Colour_Type = ''Blue''

   Test_Has_Failed = FALSE

   loop
      Little_Bean_Counter = 0

      loop
         append [The_Integer, The_Real, The_Text, The_Boolean, The_Colour] to {Simple_Destructive_Structure}
    
         breakif Little_Bean_Counter = Number_Of_Appends

         Little_Bean_Counter = Little_Bean_Counter + 1
      endloop

      # Redeclare the structure, effectively removing the fully defined
      # structure and resetting it to zero size. This test differs from 
      # the previous in that the type of the structure has changed, and 
      # the number of appends and iterations have swapped values!
      # Due to a WACA limitation (and ADA95 if we are honest) the reuse
      # of a named definition for a different type is precluded.

      {Simple_Destructive_Structure} is Simple_Structure_Type

      # If the structure has not been cleaned up, bail out. There is
      # no point continuing.

      How_Many_Now = countof {Simple_Destructive_Structure}
      if How_Many_Now != 0 then
         Test_Has_Failed = TRUE
         break
      endif

      breakif Big_Bean_Counter = Number_Of_Iterations

      Big_Bean_Counter = Big_Bean_Counter + 1

   endloop

   if Test_Has_Failed then
      [] = RPT3:Test_Failed["Structures not cleared up", Test_Number, Big_Bean_Counter]
   else
      Result_Value = Little_Bean_Counter * Big_Bean_Counter
      [] = RPT2:Test_Passed["Structures cleared", Test_Number, Result_Value]
   endif

   Test_Number = Test_Number + 1

# End Test 2

#--------------------------------------------------------------------------
# Test 3 - Now try a similar test on a structure containing an instance 
#          handle.
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test_Number, "1241-0000-01-1216", "Structures", "Structures cleared", "Structures with IH memory usage test"]

   {Structure_And_IH_Destructive_Structure} is Structure_and_IH_Type

   # Blunder round a loop ten thousand times, adding fifty
   # structures into the set of structure. This should give an 
   # indication of whether WACA returns the freed space back
   # to the heap after the structure is redeclared.

   # NB. Use the Performance Meter in the Windows NT task manager
   #     to monitor memory usage.

   Number_Of_Iterations = 10000
   Number_Of_Appends = 50

   A_Structured_Object_IH = create unique Structured_Object with An_Integer    = Test_Number &\
                                                                 A_Real        = 99.99       &\
                                                                 Some_Text     = "Some Text" &\
                                                                 A_Boolean     = FALSE       &\
                                                                 A_Colour      = ''Green''     &\
                                                                 Current_State =''Idle''

   # Test data section

   Little_Bean_Counter = 0
   Big_Bean_Counter    = 0

   Test_Has_Failed = FALSE

   loop
      Little_Bean_Counter = 0

      loop
         append [A_Structured_Object_IH] to {Structure_And_IH_Destructive_Structure}

         breakif Little_Bean_Counter = Number_Of_Appends

         Little_Bean_Counter = Little_Bean_Counter + 1
      endloop

      # Redeclare the structure, effectively removing the fully defined
      # structure and resetting it to zero size.

      {Structure_And_IH_Destructive_Structure} is Structure_and_IH_Type

      # If the structure has not been cleaned up, bail out. There is
      # no point continuing.
      How_Many_Now = countof {Structure_And_IH_Destructive_Structure}

      if How_Many_Now != 0 then
         Test_Has_Failed = TRUE
         break
      endif

      breakif Big_Bean_Counter = Number_Of_Iterations

      Big_Bean_Counter = Big_Bean_Counter + 1

   endloop

   if Test_Has_Failed then
      [] = RPT3:Test_Failed["Structures not cleared up", Test_Number, Big_Bean_Counter]
   else
      Result_Value = Little_Bean_Counter * Big_Bean_Counter
      [] = RPT2:Test_Passed["Structures cleared", Test_Number, Result_Value]
   endif

   Test_Number = Test_Number + 1

# End Test 3

#--------------------------------------------------------------------------

my_test.The_Test_Number = Test_Number',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,11 );
INSERT INTO S_SYNC VALUES ( "00000000-0000-0000-0000-0000000001e2","00000000-0000-0000-0000-000000000000",'Test_the_Structure',' Test_the_Structure
','# Set up scenario test data.
Test_Has_Passed = FALSE

My_Test_Data = find-one Test_Data
Test = My_Test_Data.The_Test_Number

#--------------------------------------------------------------------------
# Test 1
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Returning Structure", "Test returning structure"]

   The_New_Int = 100
   The_New_Col of Colour_Type = ''Red''

   {The_New_Struct} is My_Simple_Structure

   append[The_New_Int,The_New_Col] to {The_New_Struct}

   [{Returning_Structure}] = Struct5::Test_The_Structure[Test, {The_New_Struct}]

   for [the_integer, the_colour] in {Returning_Structure} do

      if the_integer = 200 then

         if the_colour = ''Blue'' then
            [] = RPT2:Test_Passed["Structures", Test, 0]
         else
            [] = RPT3:Test_Failed["Structures", Test, -1]
         endif

      else
         [] = RPT3:Test_Failed["Structures", Test, -2]
      endif

   endfor

   Test = Test + 1

# End Test 1

#--------------------------------------------------------------------------
# Test 2
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Returning Structure", "Test returning structure"]

   The_New_Int = 100
   The_New_Real = 1.0
   The_New_String = "Structures Test"
   The_New_Colour of Colour_Type = ''Blue''

   [{The_Returning_Structure}] = Struct10::Check_Returning_Structure[The_New_Int, The_New_Real, The_New_String, The_New_Colour]

   for [The_Returned_Int, The_Returned_Real, The_Returned_String, The_Returned_UDT] in {The_Returning_Structure} do

      if The_Returned_Int = 200 then

         if The_Returned_Real = 2.0 then

            if The_Returned_String = "Test Complete" then

               if The_Returned_UDT = ''Green'' then   
                  [] = RPT2:Test_Passed["Structures", Test, 0]
               else   
                  [] = RPT3:Test_Failed["Structures", Test, -1]
               endif

            else
              [] = RPT3:Test_Failed["Structures", Test, -2]
            endif

         else
            [] = RPT3:Test_Failed["Structures", Test, -3]
         endif

      else
         [] = RPT3:Test_Failed["Structures", Test, -4]
      endif

   endfor

   Test = Test + 1

# End Test 2

#--------------------------------------------------------------------------
# Test 3
#--------------------------------------------------------------------------

   [] = RPT1:Start_Test[Test, "1241-0000-01-1212", "Structures", "Returning Structure", "Test returning structure"]

   The_New_Int = 100
   The_New_Col of Colour_Type = ''Red''

   {New_Structure} is My_Simple_Structure

   append[The_New_Int, The_New_Col] to {New_Structure}

   
   [{New_Structure}] = Struct5::Test_The_Structure[Test, {New_Structure}]

   How_Many = countof{New_Structure}

   if How_Many = 2 then

      Count = 1

      for [the_integer, the_colour] in {New_Structure} do

         if the_integer = 200 then

            if the_colour = ''Blue'' then
               [] = RPT2:Test_Passed["Structures", Test, 0]
            else
               [] = RPT3:Test_Failed["Structures", Test, -1]
           endif

         else
            Count = Count + 1

            if Count = 3 then
               [] = RPT3:Test_Failed["Structures", Test, -2]
            endif

         endif

      endfor
 
   else
      [] = RPT3:Test_Failed["Structures", Test, -3]
   endif
  
   Test = Test + 1

# End Test 3

#--------------------------------------------------------------------------

My_Test_Data.The_Test_Number = Test',"ba5eda7a-def5-0000-0000-000000000000",3,'',2,12 );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000113","00000000-0000-0000-0000-00000000010b",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000115","00000000-0000-0000-0000-00000000010b",'Simple_Structure',"00000000-0000-0000-0000-00000000004a",0,'',"00000000-0000-0000-0000-000000000113",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000117","00000000-0000-0000-0000-00000000010b",'Object_Instance_Handle',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-000000000115",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000011d","00000000-0000-0000-0000-00000000011a",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000011f","00000000-0000-0000-0000-00000000011a",'Simple_Structure',"00000000-0000-0000-0000-00000000005b",0,'',"00000000-0000-0000-0000-00000000011d",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000121","00000000-0000-0000-0000-00000000011a",'Object_Instance_Handle',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-00000000011f",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000127","00000000-0000-0000-0000-000000000124",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000129","00000000-0000-0000-0000-000000000124",'Simple_Structure',"00000000-0000-0000-0000-000000000067",0,'',"00000000-0000-0000-0000-000000000127",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000012b","00000000-0000-0000-0000-000000000124",'Object_Instance_Handle',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-000000000129",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000131","00000000-0000-0000-0000-00000000012e",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000133","00000000-0000-0000-0000-00000000012e",'Three_Level_Nest',"00000000-0000-0000-0000-000000000073",0,'',"00000000-0000-0000-0000-000000000131",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000135","00000000-0000-0000-0000-00000000012e",'Two_Level_Nest',"00000000-0000-0000-0000-000000000079",0,'',"00000000-0000-0000-0000-000000000133",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000137","00000000-0000-0000-0000-00000000012e",'One_Level_Nest',"00000000-0000-0000-0000-000000000081",0,'',"00000000-0000-0000-0000-000000000135",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000139","00000000-0000-0000-0000-00000000012e",'Given_First_Level_Number',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000137",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000013b","00000000-0000-0000-0000-00000000012e",'How_Many_In_First',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000139",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000013d","00000000-0000-0000-0000-00000000012e",'Given_Second_Level_Number',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-00000000013b",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000013f","00000000-0000-0000-0000-00000000012e",'How_Many_In_Second',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-00000000013d",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000141","00000000-0000-0000-0000-00000000012e",'Given_Third_Level_Number',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-00000000013f",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000143","00000000-0000-0000-0000-00000000012e",'How_Many_In_Third',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000141",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000145","00000000-0000-0000-0000-00000000012e",'Given_Third_Level_Colour',"00000000-0000-0000-0000-000000000058",0,'',"00000000-0000-0000-0000-000000000143",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000153","00000000-0000-0000-0000-000000000150",'This_Test_Number',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000155","00000000-0000-0000-0000-000000000150",'Input_Structure',"00000000-0000-0000-0000-00000000008f",0,'',"00000000-0000-0000-0000-000000000153",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000157","00000000-0000-0000-0000-000000000150",'Number_Of_Elements',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000155",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000159","00000000-0000-0000-0000-000000000150",'Unique_Identifier_Of_IH',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000157",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000015b","00000000-0000-0000-0000-000000000150",'Testing_For',"ba5eda7a-def5-0000-0000-000000000004",0,'',"00000000-0000-0000-0000-000000000159",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000161","00000000-0000-0000-0000-00000000015e",'Test_Number',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000163","00000000-0000-0000-0000-00000000015e",'Empty_Structure',"00000000-0000-0000-0000-00000000008f",0,'',"00000000-0000-0000-0000-000000000161",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000165","00000000-0000-0000-0000-00000000015e",'Inserted_IH',"00000000-0000-0000-0000-00000000002d",0,'',"00000000-0000-0000-0000-000000000163",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000167","00000000-0000-0000-0000-00000000015e",'Testing_For',"ba5eda7a-def5-0000-0000-000000000004",0,'',"00000000-0000-0000-0000-000000000165",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000169","00000000-0000-0000-0000-00000000015e",'Filled_Structure',"00000000-0000-0000-0000-00000000008f",1,'',"00000000-0000-0000-0000-000000000167",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000016f","00000000-0000-0000-0000-00000000016c",'Test',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000171","00000000-0000-0000-0000-00000000016c",'Structure_Input',"00000000-0000-0000-0000-000000000095",0,'',"00000000-0000-0000-0000-00000000016f",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000173","00000000-0000-0000-0000-00000000016c",'The_Return_Structure',"00000000-0000-0000-0000-000000000095",1,'',"00000000-0000-0000-0000-000000000171",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000179","00000000-0000-0000-0000-000000000176",'Integer_Input',"ba5eda7a-def5-0000-0000-000000000002",0,'',"00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000017b","00000000-0000-0000-0000-000000000176",'Real_Input',"ba5eda7a-def5-0000-0000-000000000003",0,'',"00000000-0000-0000-0000-000000000179",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000017d","00000000-0000-0000-0000-000000000176",'String_Input',"ba5eda7a-def5-0000-0000-000000000004",0,'',"00000000-0000-0000-0000-00000000017b",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-00000000017f","00000000-0000-0000-0000-000000000176",'UDT_Input',"00000000-0000-0000-0000-000000000058",0,'',"00000000-0000-0000-0000-00000000017d",'' );
INSERT INTO S_SPARM VALUES ( "00000000-0000-0000-0000-000000000181","00000000-0000-0000-0000-000000000176",'Returning_Structure',"00000000-0000-0000-0000-00000000009d",1,'',"00000000-0000-0000-0000-00000000017f",'' );
INSERT INTO S_IRDT VALUES ( "00000000-0000-0000-0000-00000000002d",0,"00000000-0000-0000-0000-000000000029" );
INSERT INTO S_IRDT VALUES ( "00000000-0000-0000-0000-000000000030",1,"00000000-0000-0000-0000-000000000029" );
INSERT INTO S_IRDT VALUES ( "00000000-0000-0000-0000-000000000038",0,"00000000-0000-0000-0000-000000000034" );
INSERT INTO S_IRDT VALUES ( "00000000-0000-0000-0000-00000000003b",1,"00000000-0000-0000-0000-000000000034" );
INSERT INTO S_IRDT VALUES ( "00000000-0000-0000-0000-000000000043",0,"00000000-0000-0000-0000-00000000003f" );
INSERT INTO S_IRDT VALUES ( "00000000-0000-0000-0000-000000000046",1,"00000000-0000-0000-0000-00000000003f" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-00000000004a" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-00000000005b" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-000000000067" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-000000000073" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-000000000079" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-000000000081" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-00000000008f" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-000000000095" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-00000000009d" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-0000000000ab" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-0000000000c1" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-0000000000cf" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-0000000000e1" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-0000000000ed" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-0000000000f5" );
INSERT INTO S_SDT VALUES ( "00000000-0000-0000-0000-0000000000fb" );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-00000000004d",'S_Integer','',"00000000-0000-0000-0000-00000000004a","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-00000000004f",'S_Real','',"00000000-0000-0000-0000-00000000004a","ba5eda7a-def5-0000-0000-000000000003","00000000-0000-0000-0000-00000000004d",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000051",'S_Text','',"00000000-0000-0000-0000-00000000004a","ba5eda7a-def5-0000-0000-000000000004","00000000-0000-0000-0000-00000000004f",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000053",'S_Boolean','',"00000000-0000-0000-0000-00000000004a","ba5eda7a-def5-0000-0000-000000000001","00000000-0000-0000-0000-000000000051",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000055",'S_Colour','',"00000000-0000-0000-0000-00000000004a","00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-000000000053",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-00000000005e",'TLS_Integer','',"00000000-0000-0000-0000-00000000005b","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000060",'TLS_Real','',"00000000-0000-0000-0000-00000000005b","ba5eda7a-def5-0000-0000-000000000003","00000000-0000-0000-0000-00000000005e",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000062",'TLS_Text','',"00000000-0000-0000-0000-00000000005b","ba5eda7a-def5-0000-0000-000000000004","00000000-0000-0000-0000-000000000060",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000064",'TLS_Boolean','',"00000000-0000-0000-0000-00000000005b","ba5eda7a-def5-0000-0000-000000000001","00000000-0000-0000-0000-000000000062",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-00000000006a",'An_Integer','',"00000000-0000-0000-0000-000000000067","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-00000000006c",'A_Real','',"00000000-0000-0000-0000-000000000067","ba5eda7a-def5-0000-0000-000000000003","00000000-0000-0000-0000-00000000006a",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-00000000006e",'Some_Text','',"00000000-0000-0000-0000-000000000067","ba5eda7a-def5-0000-0000-000000000004","00000000-0000-0000-0000-00000000006c",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000070",'A_Boolean','',"00000000-0000-0000-0000-000000000067","ba5eda7a-def5-0000-0000-000000000001","00000000-0000-0000-0000-00000000006e",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000076",'Second_Nested_Structure','',"00000000-0000-0000-0000-000000000073","00000000-0000-0000-0000-000000000079","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-00000000007b",'First_Nested_Integer','',"00000000-0000-0000-0000-000000000073","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-000000000076",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-00000000007e",'Third_Nested_Structure','',"00000000-0000-0000-0000-000000000079","00000000-0000-0000-0000-000000000081","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000083",'Third_Nested_Integer','',"00000000-0000-0000-0000-000000000079","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-00000000007e",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000086",'Third_Nested_Integer','',"00000000-0000-0000-0000-000000000081","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000088",'The_Holy_Grail','',"00000000-0000-0000-0000-000000000081","00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-000000000086",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000092",'A_Defined_IH','',"00000000-0000-0000-0000-00000000008f","00000000-0000-0000-0000-00000000002d","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000098",'Int_Value','',"00000000-0000-0000-0000-000000000095","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-00000000009a",'Colour_Value','',"00000000-0000-0000-0000-000000000095","00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-000000000098",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000a0",'Int_Val','',"00000000-0000-0000-0000-00000000009d","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000a2",'Real_Val','',"00000000-0000-0000-0000-00000000009d","ba5eda7a-def5-0000-0000-000000000003","00000000-0000-0000-0000-0000000000a0",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000a4",'String_Val','',"00000000-0000-0000-0000-00000000009d","ba5eda7a-def5-0000-0000-000000000004","00000000-0000-0000-0000-0000000000a2",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000a6",'Col_Val','',"00000000-0000-0000-0000-00000000009d","00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-0000000000a4",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000ae",'An_Integer','',"00000000-0000-0000-0000-0000000000ab","00000000-0000-0000-0000-0000000000b1","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000b3",'A_Real','',"00000000-0000-0000-0000-0000000000ab","00000000-0000-0000-0000-0000000000b6","00000000-0000-0000-0000-0000000000ae",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000c4",'A_Top_Integer','',"00000000-0000-0000-0000-0000000000c1","00000000-0000-0000-0000-0000000000b1","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000c6",'A_Top_Real','',"00000000-0000-0000-0000-0000000000c1","00000000-0000-0000-0000-0000000000b6","00000000-0000-0000-0000-0000000000c4",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000c8",'A_UDT_Structure','',"00000000-0000-0000-0000-0000000000c1","00000000-0000-0000-0000-0000000000ab","00000000-0000-0000-0000-0000000000c6",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000ca",'Basic_Integer','',"00000000-0000-0000-0000-0000000000c1","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-0000000000c8",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000cc",'A_Colour','',"00000000-0000-0000-0000-0000000000c1","00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-0000000000ca",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000d2",'Alternative_Colour','',"00000000-0000-0000-0000-0000000000cf","00000000-0000-0000-0000-0000000000d5","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000d7",'Extra_Member','',"00000000-0000-0000-0000-0000000000cf","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-0000000000d2",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000e4",'Initial_Structure','',"00000000-0000-0000-0000-0000000000e1","00000000-0000-0000-0000-000000000073","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000e6",'Secondary_Structure','',"00000000-0000-0000-0000-0000000000e1","00000000-0000-0000-0000-000000000079","00000000-0000-0000-0000-0000000000e4",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000e8",'Penultimate_Structure','',"00000000-0000-0000-0000-0000000000e1","00000000-0000-0000-0000-000000000081","00000000-0000-0000-0000-0000000000e6",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000ea",'Buried_Integer','',"00000000-0000-0000-0000-0000000000e1","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-0000000000e8",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000f0",'First_Structure','',"00000000-0000-0000-0000-0000000000ed","00000000-0000-0000-0000-00000000004a","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000f2",'Second_Structure','',"00000000-0000-0000-0000-0000000000ed","00000000-0000-0000-0000-000000000081","00000000-0000-0000-0000-0000000000f0",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000f8",'Basic_Integer','',"00000000-0000-0000-0000-0000000000f5","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-0000000000fe",'SS_Integer','',"00000000-0000-0000-0000-0000000000fb","ba5eda7a-def5-0000-0000-000000000002","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000100",'SS_Real','',"00000000-0000-0000-0000-0000000000fb","ba5eda7a-def5-0000-0000-000000000003","00000000-0000-0000-0000-0000000000fe",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000102",'SS_Text','',"00000000-0000-0000-0000-0000000000fb","ba5eda7a-def5-0000-0000-000000000004","00000000-0000-0000-0000-000000000100",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000104",'SS_Boolean','',"00000000-0000-0000-0000-0000000000fb","ba5eda7a-def5-0000-0000-000000000001","00000000-0000-0000-0000-000000000102",'' );
INSERT INTO S_MBR VALUES ( "00000000-0000-0000-0000-000000000106",'SS_Colour','',"00000000-0000-0000-0000-0000000000fb","00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-000000000104",'' );
INSERT INTO S_RANGE VALUES ( "00000000-0000-0000-0000-0000000000b9",'0','100' );
INSERT INTO S_RANGE VALUES ( "00000000-0000-0000-0000-0000000000bd",'0.0','100.0' );
INSERT INTO C_C VALUES ( "00000000-0000-0000-0000-000000000023","00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000000",'Struct',' Mission statement? 
 You''re having a laugh!
',0,"00000000-0000-0000-0000-000000000000",0,'','Structures' );
INSERT INTO C_I VALUES ( "00000000-0000-0000-0000-00000000010d","00000000-0000-0000-0000-000000000000",'Struct','' );
INSERT INTO C_I VALUES ( "00000000-0000-0000-0000-000000000184","00000000-0000-0000-0000-000000000000",'StructReport','' );
INSERT INTO C_I VALUES ( "00000000-0000-0000-0000-0000000001bb","00000000-0000-0000-0000-000000000000",'StructEnv_Terminator','' );
INSERT INTO C_P VALUES ( "00000000-0000-0000-0000-00000000010f",'','Unnamed_Interface','','' );
INSERT INTO C_R VALUES ( "00000000-0000-0000-0000-000000000186",'','','Unnamed_Interface','' );
INSERT INTO C_R VALUES ( "00000000-0000-0000-0000-0000000001bd",'','','Unnamed_Interface','' );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-000000000111","00000000-0000-0000-0000-00000000010d",0,'Decode_Simple_Structure','',2 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-00000000011b","00000000-0000-0000-0000-00000000010d",0,'Decode_Simple_TL_Structure','',4 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-000000000125","00000000-0000-0000-0000-00000000010d",0,'Decode_Simple_NTL_Structure','',6 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-00000000012f","00000000-0000-0000-0000-00000000010d",0,'Decode_Three_Level_Nested_Structure','',7 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-000000000149","00000000-0000-0000-0000-00000000010d",0,'Create_Report_Data','',8 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-00000000014d","00000000-0000-0000-0000-00000000010d",0,'Delete_Report_Data','',9 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-000000000151","00000000-0000-0000-0000-00000000010d",0,'Receive_Structure_IH','',1 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-00000000015f","00000000-0000-0000-0000-00000000010d",0,'Receive_Empty_Structure_IH','',3 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-00000000016d","00000000-0000-0000-0000-00000000010d",0,'Test_The_Structure','',5 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-000000000177","00000000-0000-0000-0000-00000000010d",0,'Check_Returning_Structure','',10 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-000000000188","00000000-0000-0000-0000-000000000184",0,'Start_Test','',1 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-00000000018f","00000000-0000-0000-0000-000000000184",0,'Test_Passed','',2 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-000000000194","00000000-0000-0000-0000-000000000184",0,'Test_Failed','',3 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-000000000199","00000000-0000-0000-0000-000000000184",0,'Test_Unsupported','',4 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-00000000019c","00000000-0000-0000-0000-000000000184",0,'Test_Text','',5 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-0000000001a0","00000000-0000-0000-0000-000000000184",0,'Domain_Test_Start','',6 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-0000000001a3","00000000-0000-0000-0000-000000000184",0,'Domain_Test_Finished','',7 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-0000000001a6","00000000-0000-0000-0000-000000000184",0,'Specify_Requid','',8 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-0000000001bf","00000000-0000-0000-0000-0000000001bb",0,'Env_String','',1 );
INSERT INTO C_EP VALUES ( "00000000-0000-0000-0000-0000000001c2","00000000-0000-0000-0000-0000000001bb",0,'Env_Number','',2 );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-000000000111","ba5eda7a-def5-0000-0000-000000000000",'Decode_Simple_Structure','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-00000000011b","ba5eda7a-def5-0000-0000-000000000000",'Decode_Simple_TL_Structure','',0,'',"00000000-0000-0000-0000-000000000111" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-000000000125","ba5eda7a-def5-0000-0000-000000000000",'Decode_Simple_NTL_Structure','',0,'',"00000000-0000-0000-0000-00000000011b" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-00000000012f","ba5eda7a-def5-0000-0000-000000000000",'Decode_Three_Level_Nested_Structure','',0,'',"00000000-0000-0000-0000-000000000125" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-000000000149","ba5eda7a-def5-0000-0000-000000000000",'Create_Report_Data','',0,'',"00000000-0000-0000-0000-00000000012f" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-00000000014d","ba5eda7a-def5-0000-0000-000000000000",'Delete_Report_Data','',0,'',"00000000-0000-0000-0000-000000000149" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-000000000151","ba5eda7a-def5-0000-0000-000000000000",'Receive_Structure_IH','',0,'',"00000000-0000-0000-0000-00000000014d" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-00000000015f","ba5eda7a-def5-0000-0000-000000000000",'Receive_Empty_Structure_IH','',0,'',"00000000-0000-0000-0000-000000000151" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-00000000016d","ba5eda7a-def5-0000-0000-000000000000",'Test_The_Structure','',0,'',"00000000-0000-0000-0000-00000000015f" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-000000000177","ba5eda7a-def5-0000-0000-000000000000",'Check_Returning_Structure','',0,'',"00000000-0000-0000-0000-00000000016d" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-000000000188","ba5eda7a-def5-0000-0000-000000000000",'Start_Test','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-00000000018f","ba5eda7a-def5-0000-0000-000000000000",'Test_Passed','',0,'',"00000000-0000-0000-0000-000000000188" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-000000000194","ba5eda7a-def5-0000-0000-000000000000",'Test_Failed','',0,'',"00000000-0000-0000-0000-00000000018f" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-000000000199","ba5eda7a-def5-0000-0000-000000000000",'Test_Unsupported','',0,'',"00000000-0000-0000-0000-000000000194" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-00000000019c","ba5eda7a-def5-0000-0000-000000000000",'Test_Text','',0,'',"00000000-0000-0000-0000-000000000199" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-0000000001a0","ba5eda7a-def5-0000-0000-000000000000",'Domain_Test_Start','',0,'',"00000000-0000-0000-0000-00000000019c" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-0000000001a3","ba5eda7a-def5-0000-0000-000000000000",'Domain_Test_Finished','',0,'',"00000000-0000-0000-0000-0000000001a0" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-0000000001a6","ba5eda7a-def5-0000-0000-000000000000",'Specify_Requid','',0,'',"00000000-0000-0000-0000-0000000001a3" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-0000000001bf","ba5eda7a-def5-0000-0000-000000000000",'Env_String','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_IO VALUES ( "00000000-0000-0000-0000-0000000001c2","ba5eda7a-def5-0000-0000-000000000000",'Env_Number','',0,'',"00000000-0000-0000-0000-0000000001bf" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000114","00000000-0000-0000-0000-000000000111","ba5eda7a-def5-0000-0000-000000000002",'Test','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000116","00000000-0000-0000-0000-000000000111","00000000-0000-0000-0000-00000000004a",'Simple_Structure','',0,'',"00000000-0000-0000-0000-000000000114" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000118","00000000-0000-0000-0000-000000000111","00000000-0000-0000-0000-00000000002d",'Object_Instance_Handle','',0,'',"00000000-0000-0000-0000-000000000116" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000011e","00000000-0000-0000-0000-00000000011b","ba5eda7a-def5-0000-0000-000000000002",'Test','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000120","00000000-0000-0000-0000-00000000011b","00000000-0000-0000-0000-00000000005b",'Simple_Structure','',0,'',"00000000-0000-0000-0000-00000000011e" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000122","00000000-0000-0000-0000-00000000011b","00000000-0000-0000-0000-00000000002d",'Object_Instance_Handle','',0,'',"00000000-0000-0000-0000-000000000120" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000128","00000000-0000-0000-0000-000000000125","ba5eda7a-def5-0000-0000-000000000002",'Test','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000012a","00000000-0000-0000-0000-000000000125","00000000-0000-0000-0000-000000000067",'Simple_Structure','',0,'',"00000000-0000-0000-0000-000000000128" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000012c","00000000-0000-0000-0000-000000000125","00000000-0000-0000-0000-00000000002d",'Object_Instance_Handle','',0,'',"00000000-0000-0000-0000-00000000012a" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000132","00000000-0000-0000-0000-00000000012f","ba5eda7a-def5-0000-0000-000000000002",'Test','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000134","00000000-0000-0000-0000-00000000012f","00000000-0000-0000-0000-000000000073",'Three_Level_Nest','',0,'',"00000000-0000-0000-0000-000000000132" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000136","00000000-0000-0000-0000-00000000012f","00000000-0000-0000-0000-000000000079",'Two_Level_Nest','',0,'',"00000000-0000-0000-0000-000000000134" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000138","00000000-0000-0000-0000-00000000012f","00000000-0000-0000-0000-000000000081",'One_Level_Nest','',0,'',"00000000-0000-0000-0000-000000000136" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000013a","00000000-0000-0000-0000-00000000012f","ba5eda7a-def5-0000-0000-000000000002",'Given_First_Level_Number','',0,'',"00000000-0000-0000-0000-000000000138" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000013c","00000000-0000-0000-0000-00000000012f","ba5eda7a-def5-0000-0000-000000000002",'How_Many_In_First','',0,'',"00000000-0000-0000-0000-00000000013a" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000013e","00000000-0000-0000-0000-00000000012f","ba5eda7a-def5-0000-0000-000000000002",'Given_Second_Level_Number','',0,'',"00000000-0000-0000-0000-00000000013c" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000140","00000000-0000-0000-0000-00000000012f","ba5eda7a-def5-0000-0000-000000000002",'How_Many_In_Second','',0,'',"00000000-0000-0000-0000-00000000013e" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000142","00000000-0000-0000-0000-00000000012f","ba5eda7a-def5-0000-0000-000000000002",'Given_Third_Level_Number','',0,'',"00000000-0000-0000-0000-000000000140" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000144","00000000-0000-0000-0000-00000000012f","ba5eda7a-def5-0000-0000-000000000002",'How_Many_In_Third','',0,'',"00000000-0000-0000-0000-000000000142" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000146","00000000-0000-0000-0000-00000000012f","00000000-0000-0000-0000-000000000058",'Given_Third_Level_Colour','',0,'',"00000000-0000-0000-0000-000000000144" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000154","00000000-0000-0000-0000-000000000151","ba5eda7a-def5-0000-0000-000000000002",'This_Test_Number','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000156","00000000-0000-0000-0000-000000000151","00000000-0000-0000-0000-00000000008f",'Input_Structure','',0,'',"00000000-0000-0000-0000-000000000154" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000158","00000000-0000-0000-0000-000000000151","ba5eda7a-def5-0000-0000-000000000002",'Number_Of_Elements','',0,'',"00000000-0000-0000-0000-000000000156" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000015a","00000000-0000-0000-0000-000000000151","ba5eda7a-def5-0000-0000-000000000002",'Unique_Identifier_Of_IH','',0,'',"00000000-0000-0000-0000-000000000158" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000015c","00000000-0000-0000-0000-000000000151","ba5eda7a-def5-0000-0000-000000000004",'Testing_For','',0,'',"00000000-0000-0000-0000-00000000015a" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000162","00000000-0000-0000-0000-00000000015f","ba5eda7a-def5-0000-0000-000000000002",'Test_Number','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000164","00000000-0000-0000-0000-00000000015f","00000000-0000-0000-0000-00000000008f",'Empty_Structure','',0,'',"00000000-0000-0000-0000-000000000162" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000166","00000000-0000-0000-0000-00000000015f","00000000-0000-0000-0000-00000000002d",'Inserted_IH','',0,'',"00000000-0000-0000-0000-000000000164" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000168","00000000-0000-0000-0000-00000000015f","ba5eda7a-def5-0000-0000-000000000004",'Testing_For','',0,'',"00000000-0000-0000-0000-000000000166" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000016a","00000000-0000-0000-0000-00000000015f","00000000-0000-0000-0000-00000000008f",'Filled_Structure','',1,'',"00000000-0000-0000-0000-000000000168" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000170","00000000-0000-0000-0000-00000000016d","ba5eda7a-def5-0000-0000-000000000002",'Test','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000172","00000000-0000-0000-0000-00000000016d","00000000-0000-0000-0000-000000000095",'Structure_Input','',0,'',"00000000-0000-0000-0000-000000000170" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000174","00000000-0000-0000-0000-00000000016d","00000000-0000-0000-0000-000000000095",'The_Return_Structure','',1,'',"00000000-0000-0000-0000-000000000172" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000017a","00000000-0000-0000-0000-000000000177","ba5eda7a-def5-0000-0000-000000000002",'Integer_Input','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000017c","00000000-0000-0000-0000-000000000177","ba5eda7a-def5-0000-0000-000000000003",'Real_Input','',0,'',"00000000-0000-0000-0000-00000000017a" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000017e","00000000-0000-0000-0000-000000000177","ba5eda7a-def5-0000-0000-000000000004",'String_Input','',0,'',"00000000-0000-0000-0000-00000000017c" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000180","00000000-0000-0000-0000-000000000177","00000000-0000-0000-0000-000000000058",'UDT_Input','',0,'',"00000000-0000-0000-0000-00000000017e" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000182","00000000-0000-0000-0000-000000000177","00000000-0000-0000-0000-00000000009d",'Returning_Structure','',1,'',"00000000-0000-0000-0000-000000000180" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000018a","00000000-0000-0000-0000-000000000188","ba5eda7a-def5-0000-0000-000000000002",'Test_Number','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000018b","00000000-0000-0000-0000-000000000188","ba5eda7a-def5-0000-0000-000000000004",'Requid','',0,'',"00000000-0000-0000-0000-00000000018a" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000018c","00000000-0000-0000-0000-000000000188","ba5eda7a-def5-0000-0000-000000000004",'Invoking_Domain','',0,'',"00000000-0000-0000-0000-00000000018b" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000018d","00000000-0000-0000-0000-000000000188","ba5eda7a-def5-0000-0000-000000000004",'Invoking_Object','',0,'',"00000000-0000-0000-0000-00000000018c" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000018e","00000000-0000-0000-0000-000000000188","ba5eda7a-def5-0000-0000-000000000004",'Purpose','',0,'',"00000000-0000-0000-0000-00000000018d" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000191","00000000-0000-0000-0000-00000000018f","ba5eda7a-def5-0000-0000-000000000004",'Test_Object_Domain','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000192","00000000-0000-0000-0000-00000000018f","ba5eda7a-def5-0000-0000-000000000002",'Test_Number','',0,'',"00000000-0000-0000-0000-000000000191" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000193","00000000-0000-0000-0000-00000000018f","ba5eda7a-def5-0000-0000-000000000002",'Test_Value','',0,'',"00000000-0000-0000-0000-000000000192" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000196","00000000-0000-0000-0000-000000000194","ba5eda7a-def5-0000-0000-000000000004",'Failed_Domain_Object','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000197","00000000-0000-0000-0000-000000000194","ba5eda7a-def5-0000-0000-000000000002",'Failed_Test_Number','',0,'',"00000000-0000-0000-0000-000000000196" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-000000000198","00000000-0000-0000-0000-000000000194","ba5eda7a-def5-0000-0000-000000000002",'Failed_Test_Value','',0,'',"00000000-0000-0000-0000-000000000197" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000019b","00000000-0000-0000-0000-000000000199","ba5eda7a-def5-0000-0000-000000000002",'Unsupported_Test_Number','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000019e","00000000-0000-0000-0000-00000000019c","ba5eda7a-def5-0000-0000-000000000002",'Test_Number','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-00000000019f","00000000-0000-0000-0000-00000000019c","ba5eda7a-def5-0000-0000-000000000004",'Free_Text','',0,'',"00000000-0000-0000-0000-00000000019e" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-0000000001a2","00000000-0000-0000-0000-0000000001a0","ba5eda7a-def5-0000-0000-000000000004",'This_Domain_Name','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-0000000001a5","00000000-0000-0000-0000-0000000001a3","ba5eda7a-def5-0000-0000-000000000004",'This_Domain_Name','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-0000000001a8","00000000-0000-0000-0000-0000000001a6","ba5eda7a-def5-0000-0000-000000000002",'Requid_Test_Number','',0,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-0000000001a9","00000000-0000-0000-0000-0000000001a6","ba5eda7a-def5-0000-0000-000000000004",'The_Requid_Itself','',0,'',"00000000-0000-0000-0000-0000000001a8" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-0000000001c1","00000000-0000-0000-0000-0000000001bf","ba5eda7a-def5-0000-0000-000000000004",'Env_Text','',1,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_PP VALUES ( "00000000-0000-0000-0000-0000000001c4","00000000-0000-0000-0000-0000000001c2","ba5eda7a-def5-0000-0000-000000000002",'Env_Integer','',1,'',"00000000-0000-0000-0000-000000000000" );
INSERT INTO C_IR VALUES ( "00000000-0000-0000-0000-00000000010f","00000000-0000-0000-0000-00000000010d","00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000110" );
INSERT INTO C_IR VALUES ( "00000000-0000-0000-0000-000000000186","00000000-0000-0000-0000-000000000184","00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000187" );
INSERT INTO C_IR VALUES ( "00000000-0000-0000-0000-0000000001bd","00000000-0000-0000-0000-0000000001bb","00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-0000000001be" );
INSERT INTO C_PO VALUES ( "00000000-0000-0000-0000-000000000110","00000000-0000-0000-0000-000000000023",'Struct',0,0,'' );
INSERT INTO C_PO VALUES ( "00000000-0000-0000-0000-000000000187","00000000-0000-0000-0000-000000000023",'Report',0,0,'RPT' );
INSERT INTO C_PO VALUES ( "00000000-0000-0000-0000-0000000001be","00000000-0000-0000-0000-000000000023",'Env_Terminator',0,0,'ET' );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001aa","00000000-0000-0000-0000-000000000188","00000000-0000-0000-0000-000000000186" );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001ac","00000000-0000-0000-0000-00000000018f","00000000-0000-0000-0000-000000000186" );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001ae","00000000-0000-0000-0000-000000000194","00000000-0000-0000-0000-000000000186" );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001b0","00000000-0000-0000-0000-000000000199","00000000-0000-0000-0000-000000000186" );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001b2","00000000-0000-0000-0000-00000000019c","00000000-0000-0000-0000-000000000186" );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001b4","00000000-0000-0000-0000-0000000001a0","00000000-0000-0000-0000-000000000186" );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001b6","00000000-0000-0000-0000-0000000001a3","00000000-0000-0000-0000-000000000186" );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001b8","00000000-0000-0000-0000-0000000001a6","00000000-0000-0000-0000-000000000186" );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001c5","00000000-0000-0000-0000-0000000001bf","00000000-0000-0000-0000-0000000001bd" );
INSERT INTO SPR_REP VALUES ( "00000000-0000-0000-0000-0000000001c7","00000000-0000-0000-0000-0000000001c2","00000000-0000-0000-0000-0000000001bd" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004b0","00000000-0000-0000-0000-000000000111","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004b2","00000000-0000-0000-0000-00000000011b","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004b4","00000000-0000-0000-0000-000000000125","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004b6","00000000-0000-0000-0000-00000000012f","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004b8","00000000-0000-0000-0000-000000000149","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004ba","00000000-0000-0000-0000-00000000014d","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004bc","00000000-0000-0000-0000-000000000151","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004be","00000000-0000-0000-0000-00000000015f","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004c0","00000000-0000-0000-0000-00000000016d","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_PEP VALUES ( "00000000-0000-0000-0000-0000000004c2","00000000-0000-0000-0000-000000000177","00000000-0000-0000-0000-00000000010f" );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001aa",'','','',3,2,1 );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001ac",'','','',3,2,2 );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001ae",'','','',3,2,3 );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001b0",'','','',3,2,4 );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001b2",'','','',3,2,5 );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001b4",'','','',3,2,6 );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001b6",'','','',3,2,7 );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001b8",'','','',3,2,8 );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001c5",'','','',3,2,1 );
INSERT INTO SPR_RO VALUES ( "00000000-0000-0000-0000-0000000001c7",'','','',3,2,2 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004b0",'','','',3,6,0 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004b2",'','','',3,6,0 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004b4",'','','',3,6,0 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004b6",'','','',3,6,0 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004b8",'','','',3,6,0 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004ba",'','','',3,6,0 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004bc",'','','',3,6,0 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004be",'','','',3,6,0 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004c0",'','','',3,6,0 );
INSERT INTO SPR_PO VALUES ( "00000000-0000-0000-0000-0000000004c2",'','','',3,6,0 );
INSERT INTO SM_SM VALUES ( "00000000-0000-0000-0000-000000000227",'',0 );
INSERT INTO SM_STATE VALUES ( "00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'Idle',1,0 );
INSERT INTO SM_STATE VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'Decode_Simple',2,0 );
INSERT INTO SM_STATE VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'Decode_Complex',3,0 );
INSERT INTO SM_STATE VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'Failed',4,0 );
INSERT INTO SM_STATE VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'Decode_Simple_TL',5,0 );
INSERT INTO SM_STATE VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'Decode_Simple_NTL',6,0 );
INSERT INTO SM_STATE VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'Finished',8,0 );
INSERT INTO SM_EVT VALUES ( "00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",1,'Start_Simple',0,'','','' );
INSERT INTO SM_EVT VALUES ( "00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",2,'Start_Complex',0,'','','' );
INSERT INTO SM_EVT VALUES ( "00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",3,'Finished',0,'','','' );
INSERT INTO SM_EVT VALUES ( "00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",4,'Fault',0,'','','' );
INSERT INTO SM_EVT VALUES ( "00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",5,'Start_TL_Simple',0,'','','' );
INSERT INTO SM_EVT VALUES ( "00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",6,'Start_NTL_Simple',0,'','','' );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEME VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-00000000039a","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-0000000003a8","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-0000000003bc","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-0000000003ca","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-0000000003de","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-0000000003ec","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-000000000406","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-000000000414","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-000000000440","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-00000000044e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-000000000468","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_NSTXN VALUES ( "00000000-0000-0000-0000-000000000476","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000022f","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_EIGN VALUES ( "00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000",'' );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-00000000039a","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000238","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-0000000003a8","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000241","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-0000000003bc","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000253","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-0000000003ca","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000025c","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-0000000003de","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-0000000003ec","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-000000000406","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-000000000414","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-000000000440","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-00000000044e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-000000000468","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000265","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TXN VALUES ( "00000000-0000-0000-0000-000000000476","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000024a","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_MOORE VALUES ( "00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_MOAH VALUES ( "00000000-0000-0000-0000-000000000231","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000022f" );
INSERT INTO SM_MOAH VALUES ( "00000000-0000-0000-0000-00000000023a","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000238" );
INSERT INTO SM_MOAH VALUES ( "00000000-0000-0000-0000-000000000243","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000241" );
INSERT INTO SM_MOAH VALUES ( "00000000-0000-0000-0000-00000000024c","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000024a" );
INSERT INTO SM_MOAH VALUES ( "00000000-0000-0000-0000-000000000255","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000253" );
INSERT INTO SM_MOAH VALUES ( "00000000-0000-0000-0000-00000000025e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000025c" );
INSERT INTO SM_MOAH VALUES ( "00000000-0000-0000-0000-000000000267","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000265" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-000000000231","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-00000000023a","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-000000000243","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-00000000024c","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-000000000255","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-00000000025e","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-000000000267","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-00000000039e","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-0000000003ac","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-0000000003c0","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-0000000003ce","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-0000000003e2","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-0000000003f0","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-00000000040a","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-000000000418","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-000000000444","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-000000000452","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-00000000046c","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_AH VALUES ( "00000000-0000-0000-0000-00000000047a","00000000-0000-0000-0000-000000000227" );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-000000000231","00000000-0000-0000-0000-000000000227",3,'','',0 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-00000000023a","00000000-0000-0000-0000-000000000227",3,'[] = RPT1:Start_Test[Test, "Null Requid", "Structures", "Structured_Object", "generate simple decode"]

Count = 1
Has_Failed = FALSE

# How many in the set

How_Many = countof {A_Simple_Structure}

for [the_integer, the_real, the_text, the_boolean, the_colour] in {A_Simple_Structure} do

   local_integer = the_integer
   local_real    = the_real
   local_text    = the_text
   local_boolean = the_boolean
   local_colour  = the_colour 

   # We are only interested in the final value in the set, otherwise
   # there would be numerous passes shown in the results file
   # for this test.

   if Count = How_Many then

      # This is the position in the set that we are interested in
      if local_integer = this.An_Integer and \
         local_real    = this.A_Real and \
         local_text    = this.Some_Text and \
         local_boolean = this.A_Boolean and \
         local_colour  = this.A_Colour then

         [] = RPT2:Test_Passed[this.Some_Text, Test, this.An_Integer]
       else
         [] = RPT3:Test_Failed[this.Some_Text, Test, this.An_Integer]
         Has_Failed = TRUE

       endif

   endif

   Count = Count + 1

endfor


if Has_Failed then
   generate SO4:Fault() to this
else
   generate SO3:Finished() to this
endif

','',2 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-000000000243","00000000-0000-0000-0000-000000000227",3,'','',0 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-00000000024c","00000000-0000-0000-0000-000000000227",3,'','',0 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-000000000255","00000000-0000-0000-0000-000000000227",3,'[] = RPT1:Start_Test[Test, "Null Requid", "Structures", "Structured_Object", "generate simple TL decode"]

Count = 1
Has_Failed = FALSE

# How many in the set

How_Many = countof {A_TL_Structure}

for [the_integer, the_real, the_text, the_boolean] in {A_TL_Structure} do

   local_integer = the_integer
   local_real    = the_real
   local_text    = the_text
   local_boolean = the_boolean

   # We are only interested in the final value in the set, otherwise
   # there would be numerous passes shown in the results file
   # for this test.

   if Count = How_Many then

      # This is the position in the set that we are interested in
      if local_integer = this.An_Integer and \
         local_real    = this.A_Real and \
         local_text    = this.Some_Text and \
         local_boolean = this.A_Boolean then

         [] = RPT2:Test_Passed[this.Some_Text, Test, this.An_Integer]
       else
         [] = RPT3:Test_Failed[this.Some_Text, Test, this.An_Integer]
         Has_Failed = TRUE

       endif

   endif

   Count = Count + 1

endfor

if Has_Failed then
   generate SO4:Fault() to this
else
   generate SO3:Finished() to this
endif

','',2 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-00000000025e","00000000-0000-0000-0000-000000000227",3,'[] = RPT1:Start_Test[Test, "Null Requid", "Structures", "Structured_Object", "generate simple NTL decode"]

Count = 1
Has_Failed = FALSE

# How many in the set

How_Many = countof {A_NTL_Structure}

for [the_integer, the_real, the_text, the_boolean] in {A_NTL_Structure} do

   local_integer = the_integer
   local_real    = the_real
   local_text    = the_text
   local_boolean = the_boolean

   # We are only interested in the final value in the set, otherwise
   # there would be numerous passes shown in the results file
   # for this test.

   if Count = How_Many then

      # This is the position in the set that we are interested in
      if local_integer = this.An_Integer and \
         local_real    = this.A_Real and \
         local_text    = this.Some_Text and \
         local_boolean = this.A_Boolean then

         [] = RPT2:Test_Passed[this.Some_Text, Test, this.An_Integer]
       else
         [] = RPT3:Test_Failed[this.Some_Text, Test, this.An_Integer]
         Has_Failed = TRUE

       endif

   endif

   Count = Count + 1

endfor


if Test = 41 then 

   [] = Struct9::Delete_Report_Data[]

endif

if Has_Failed then
   generate SO4:Fault() to this
else
   generate SO3:Finished() to this
endif

','',2 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-000000000267","00000000-0000-0000-0000-000000000227",3,'','',0 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-00000000039e","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-0000000003ac","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-0000000003c0","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-0000000003ce","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-0000000003e2","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-0000000003f0","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-00000000040a","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-000000000418","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-000000000444","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-000000000452","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-00000000046c","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_ACT VALUES ( "00000000-0000-0000-0000-00000000047a","00000000-0000-0000-0000-000000000227",3,'','',6 );
INSERT INTO SM_EVTDI VALUES ( "00000000-0000-0000-0000-00000000029e","00000000-0000-0000-0000-000000000227",'Test','',"ba5eda7a-def5-0000-0000-000000000002",'',"00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_EVTDI VALUES ( "00000000-0000-0000-0000-0000000002a0","00000000-0000-0000-0000-000000000227",'A_Simple_Structure','',"00000000-0000-0000-0000-00000000004a",'',"00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-00000000029e" );
INSERT INTO SM_EVTDI VALUES ( "00000000-0000-0000-0000-000000000362","00000000-0000-0000-0000-000000000227",'Test','',"ba5eda7a-def5-0000-0000-000000000002",'',"00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_EVTDI VALUES ( "00000000-0000-0000-0000-000000000364","00000000-0000-0000-0000-000000000227",'A_TL_Structure','',"00000000-0000-0000-0000-00000000005b",'',"00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000362" );
INSERT INTO SM_EVTDI VALUES ( "00000000-0000-0000-0000-000000000396","00000000-0000-0000-0000-000000000227",'Test','',"ba5eda7a-def5-0000-0000-000000000002",'',"00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_EVTDI VALUES ( "00000000-0000-0000-0000-000000000398","00000000-0000-0000-0000-000000000227",'A_NTL_Structure','',"00000000-0000-0000-0000-000000000067",'',"00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000396" );
INSERT INTO SM_ISM VALUES ( "00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000029" );
INSERT INTO SM_SEVT VALUES ( "00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEVT VALUES ( "00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEVT VALUES ( "00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEVT VALUES ( "00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEVT VALUES ( "00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_SEVT VALUES ( "00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_LEVT VALUES ( "00000000-0000-0000-0000-00000000026e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_LEVT VALUES ( "00000000-0000-0000-0000-0000000002a2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_LEVT VALUES ( "00000000-0000-0000-0000-0000000002d2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_LEVT VALUES ( "00000000-0000-0000-0000-000000000302","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_LEVT VALUES ( "00000000-0000-0000-0000-000000000332","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_LEVT VALUES ( "00000000-0000-0000-0000-000000000366","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000000" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-00000000039e","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000039a" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-0000000003ac","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-0000000003a8" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-0000000003c0","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-0000000003bc" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-0000000003ce","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-0000000003ca" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-0000000003e2","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-0000000003de" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-0000000003f0","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-0000000003ec" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-00000000040a","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000406" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-000000000418","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000414" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-000000000444","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000440" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-000000000452","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-00000000044e" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-00000000046c","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000468" );
INSERT INTO SM_TAH VALUES ( "00000000-0000-0000-0000-00000000047a","00000000-0000-0000-0000-000000000227","00000000-0000-0000-0000-000000000476" );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000004",1,"00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000000",7 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000006",1,"00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000009",1,"00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000000c",1,"00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000000f",1,"00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000012",1,"00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000015",1,"00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000018",1,"00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000001b",1,"00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000001e",1,"00000000-0000-0000-0000-000000000004","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000021",1,"00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000000",7 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000023",1,"00000000-0000-0000-0000-000000000021","00000000-0000-0000-0000-000000000000",2 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000025",1,"00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000023",7 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000027",1,"00000000-0000-0000-0000-000000000021","00000000-0000-0000-0000-000000000000",7 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000029",1,"00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000",4 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000002d",1,"00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000030",1,"00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000034",1,"00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000",4 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000038",1,"00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000003b",1,"00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000003f",1,"00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000",4 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000043",1,"00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000046",1,"00000000-0000-0000-0000-000000000025","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000004a",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000058",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000005b",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000067",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000073",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000079",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000081",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000008f",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000095",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000009d",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000a9",1,"00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000023",7 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000ab",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000b1",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000b6",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000b9",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000bd",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000c1",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000cf",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000d5",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000da",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000e1",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000ed",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000f5",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000000fb",1,"00000000-0000-0000-0000-0000000000a9","00000000-0000-0000-0000-000000000000",3 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000109",1,"00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000023",7 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000010b",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000010d",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",6 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000011a",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000124",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000012e",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000148",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000014c",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000150",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000015e",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-00000000016c",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000176",1,"00000000-0000-0000-0000-000000000109","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-000000000184",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",6 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001bb",1,"00000000-0000-0000-0000-000000000027","00000000-0000-0000-0000-000000000000",6 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001ca",1,"00000000-0000-0000-0000-000000000000","00000000-0000-0000-0000-000000000023",7 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001cc",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001ce",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001d0",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001d2",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001d4",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001d6",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001d8",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001da",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001dc",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001de",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001e0",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO PE_PE VALUES ( "00000000-0000-0000-0000-0000000001e2",1,"00000000-0000-0000-0000-0000000001ca","00000000-0000-0000-0000-000000000000",1 );
INSERT INTO model VALUES ( 'maslin' );
INSERT INTO option VALUES ( 'maslin','actiondialect','WASL' );
INSERT INTO option VALUES ( 'maslin','projectroot','./convertdir/Struct/' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000006","00000000-0000-0000-0000-000000000000",'MASLtype','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000009","00000000-0000-0000-0000-000000000000",'MASLunique','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000000c","00000000-0000-0000-0000-000000000000",'device','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000000f","00000000-0000-0000-0000-000000000000",'duration','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000012","00000000-0000-0000-0000-000000000000",'wstring','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000015","00000000-0000-0000-0000-000000000000",'long_integer','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000018","00000000-0000-0000-0000-000000000000",'byte','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000001b","00000000-0000-0000-0000-000000000000",'wcharacter','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000001e","00000000-0000-0000-0000-000000000000",'character','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000002d","00000000-0000-0000-0000-000000000000",'inst_ref<Structured_Object>','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000030","00000000-0000-0000-0000-000000000000",'inst_ref_set<Structured_Object>','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000038","00000000-0000-0000-0000-000000000000",'inst_ref<Report_Data>','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000003b","00000000-0000-0000-0000-000000000000",'inst_ref_set<Report_Data>','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000043","00000000-0000-0000-0000-000000000000",'inst_ref<Test_Data>','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000046","00000000-0000-0000-0000-000000000000",'inst_ref_set<Test_Data>','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000004a","00000000-0000-0000-0000-000000000000",'Simple_Structure_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000058","00000000-0000-0000-0000-000000000000",'Colour_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000005b","00000000-0000-0000-0000-000000000000",'Type_Linked_Simple_Structure_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000067","00000000-0000-0000-0000-000000000000",'Name_and_Type_Linked_Simple_Structure_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000073","00000000-0000-0000-0000-000000000000",'First_Nested_Structure_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000079","00000000-0000-0000-0000-000000000000",'Second_Nested_Structure_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000081","00000000-0000-0000-0000-000000000000",'Third_Nested_Structure_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000008f","00000000-0000-0000-0000-000000000000",'Structure_and_IH_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-000000000095","00000000-0000-0000-0000-000000000000",'My_Simple_Structure','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-00000000009d","00000000-0000-0000-0000-000000000000",'My_Second_Structure','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000ab","00000000-0000-0000-0000-000000000000",'UDT_Structure_Type',' This structure shall contain user defined types.
','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000b1","00000000-0000-0000-0000-000000000000",'UDT_Integer_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000b6","00000000-0000-0000-0000-000000000000",'UDT_Real_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000b9","00000000-0000-0000-0000-000000000000",'UDT_Integer_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000bd","00000000-0000-0000-0000-000000000000",'UDT_Real_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000c1","00000000-0000-0000-0000-000000000000",'Complex_UDT_Structure_Type',' This structure shall contain a structure, a couple of user 
 defined types and a simple integer base type.
 The UDT data shall have the same name and type as those 
 defined in the contained structure.
','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000cf","00000000-0000-0000-0000-000000000000",'Different_Structure_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000d5","00000000-0000-0000-0000-000000000000",'Alternative_Colour_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000da","00000000-0000-0000-0000-000000000000",'Alternative_Colour_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000e1","00000000-0000-0000-0000-000000000000",'Multiple_Structures_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000ed","00000000-0000-0000-0000-000000000000",'Two_Structures_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000f5","00000000-0000-0000-0000-000000000000",'Very_Simple_Structure_Type','','' );
INSERT INTO S_DT VALUES ( "00000000-0000-0000-0000-0000000000fb","00000000-0000-0000-0000-000000000000",'Second_Simple_Structure_Type','','' );
